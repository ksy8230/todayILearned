---
title: NHN FORWARD
date: 2022-11-24
tags: ["review"]
publish: false
---

(사진)   

2022년 11월 24일 목요일 nhn forward에 다녀오며 느낀점을 적어보자.   
우선 기술 컨퍼런스 자체가 처음이라 굉장히 어벙벙했다. 긴 줄이 보여서 뭔지도 모르고 일단 서서 기다리다 깃헙에서 포춘쿠키를 받은 자랑부터, 생각보다 정말 많은 사람들이 지식과 경험에 관심을 갖고 기꺼이 시간을 내서 참석하는 문화가 있다는 걸 육안으로 체험한 계기가 되었다.   
나는 사실 2021 nhn forward에서 "결국 자바스크립트를 알아보기로 했다" 세션을 진행해 주신 이진우님의 이야기가 인상 깊고 내용이 유익해 올해는 꼭 오프라인으로 참석해야지라며 신청을 했는데 이번 포워드에서는 자바스크립트 본질에 대한 세션보다는 프론트엔드 개발 라이브러리로 핫한 리액트와 관련된 내용이 더 많았던 것 같다. 다른 회사의 프론트엔드 개발자들이 관심 갖고 유용하다 생각하는 업무 방식과 기술 스택을 엿보고 싶은 마음이 1.5순위였는데 일단 그 범주에 올해도 여전히 리액트가 있었음에 안도(?)아닌 안도를 했다.   

### 마이크로 프론트엔드
키워드만 놓고 봤을 땐 새로운 기술이 또(!) 나온 줄 알았다. 마이크로 프론트엔드란 대규모 서비스에서 개발 범위에 있는 아주 많은 서비스들의 프론트 개발을 운용하기 위해 나온 단어이다.   
해당 세션에서는 nhn 두레이 리뉴얼을 예시로 진행됐다.   
두레이는 기본 베이스가 문서형 일정 관리 시스템이라 생각하는데 nhn사는 내년을 목표로 두레이에 메일 기능, 드라이브 기능, 결제 기능 등 조금 더 거대한 서비스를 제공하는 두레이로 제공할 계획이라 했다. 이런 경우에 각 서비스들을 하나의 리액트 프로젝트 안에서 페이지별로 개발하면 어떤 문제가 생길까?   
우리가 단일 기능 위주의 독립적인 함수 단위로 개발하는 이유를 생각해 보면 어렴풋하게나마 그 걱정들을 유추해 볼 수 있을 것이다. 두레이라는 큰 엄마 밑에 각 서비스 별로 자식들을 관리했을 때 개발-테스트-배포-QA 의 범위가 줄어들 것이다. 내가 수정한 건 메일 기능인데 드라이브 기능을 담당하는 코드까지 포함해서 테스트한다는 건 불필요한 시간을 소요할 수도 있기 때문이다.   
그렇다면 이 수많은 서비스별 프로젝트들은 어땋게 만들어볼 수 있을까?   
서비스별로 프로젝트를 만들어놓고 각 서비스끼리의 연결은 http://domain/v1/mail http://domain/v1/driver 식으로 링크만 맞춰서 연결해 주면 결과물 자체는 같을지 모르나 링크를 변경할 때마다 같은 모듈을 로드하는 경우가 생길 것이다. 왜냐면 이 두 링크는 같은 개발 모듈이 아닌 내용만 같은 다른 개발 모듈을 불러올 것이기 때문이다.   
여기에서 새로 'webpack 5 module federation' 키워드가 던져졌다.   

webpack은 웹앱을 최적화시켜 구동시키기 위해 웹앱을 만들어주기 위해 만들어진 수많은 자바스크립트 파일들을 하나의 묶음(번들) 단위로 만들고 압축시키는 역할을 한다. 그런데 이제는 이 webpack이 빌드 단계가 아닌 런타임 단계에서 호스트 최상단으로 여기저기 개발된 각 서비스들의 코드 조각들을 모아 하나의 부모 앱으로 실행시킨다.   

'webpack 5 module federation을 이용하면 각 서비스별로 개발 운용한 뒤 큰 부모 서비스에서 모아 배포하는 이상적인 작업 형태가 가능'해진 것이다. 이제는 기술이 발전하다못해 함수들만 모아 배포시키는 게 아닌 프로젝트 덩어리를 모아 최종 부모 프로젝트에 배포시키는 단계로 발전한 것 같다.   

### 디자인 시스템
디자인 시스템은 사실 이미 현업에서 운용하고 있지만 짜집기 코드가 많고 (리팩토링이 안 된 개발만을 위한 소스들) 어떻게든 굴러가는 형태로 배포시켜 사용 중이라 개인적으로 마음에 들지 않는 부분이 굉장히 많았다. 이런 내 현주소에서 어떤 점부터 개선점을 찾아야할지 궁금해 해당 세션을 들었는데 사실 여전히 뜬구름 잡는 이야기에 머물러있기는 하다. 그럼에도 디자인 시스템을 놓고 싶지 않은 이유는 디자인 시스템이란 완료 단계가 없는 시스템이라 생각하고 꾸준히 가져가 현 시점에서 가능한 만큼이라도 디자인의 통일성을 다지고 싶기 때문이다. 세션의 내용은 크게 세 가지로 정리할 수 있겠다.   

1 디자인 시스템의 가치      
2 진화하는 디자인 시스템      
3 디자인 시스템 언제 시작할까   

디자인 시스템 가치는 '효율성과 사용성'을 같이 가져가기 위해 만드는 시스템이라 생각한다. 디자인은 다지아너의 영역이나 엔지니어는 몰라도 된다의 방식은 더 이상 현업에서 채택하지 않는 추세인 것 같다. 오히려 엔지니어 쪽에서 디자인 시스템에 더 많은 관심과 피드백을 줘야 실용적인 디자인 시스템이 나온다. 왜냐면 결국 그 다자인을 코드로 실현시키는 작업자가 엔지니어이고 그 디자인을 미리 구동해 보는 환경이 디자인 시스템이 되어야되기 때문이다.   

현재 대부분의 회사에서 채택하고 있는 디자인 툴은 포토샵을 지나 스케치를 지나 피그마에 머물러있다고 한다. 그도 그럴 것이 요즘 개발 방식이 점점 컴포넌트와 같은 작은 단위부터 시작하는 것과 일맥상통하게 디자인도 그에 맞게 작은 개체 디자인부터 관리하는 방향으로 적용되고 있기 때문이다. 여기에 머터리얼 디자인이라는 개념이 생긴다. 디자인 시스템은 부모 디자인이 존재하고 이 부모 디자인을 참조하는 하위 디자인 컴포넌트들이 만들어지고 관리되어야 한다. 피그마를 사용하면 컴포넌트의 개념을 적용하지 않으면 툴을 사용하기 힘들게 만들었기 때문에 많은 회사에서 디자인 시스템을 구축할 때 피그마를 사용한다고 한다.   

그렇다면 이런 디자인 시스템을 시작해야하는 시기는 언제일까? 팀이 점점 커지면 일관성이 무너지기 쉽다. 업무는 사람 자체가 문서화되어 있어야하는데 개별 직원들마다 시스템을 갖고 있다면 아주 작은 부분부터 시작해 치명적인 부분까지 비효율적인 방향으로 영향을 끼칠 것이다. 본 개발자도 손 대기 힘든 지독한 레거시 코드를 피하는 길은 앞서 말한 마이크로 프론트엔드 개발 방식만이 아닌 디자인 시스템을 구축하는 것도 방안이 될 거라 생각한다. 단순히 뷰단에서 색상값이 중구난방이고 레이아웃이 제각각인 결과물을 개선하는 게 아닌 코드 관리도 같이 가져갈 수 있다고 생각한다. 세션에서는 여기에 대한 예시로 디자인 토큰값 적용을 들었다. #fff 색상 코드를 그대로 사용하는 것이 아닌 md.design.darkTheme.white 식으로 코드화시킨다면 디자이너와 엔지니어가 하얀색에 대해 색상값을 떠오르고 접근할 때 동일한 싱크를 가져갈 수 있고 이 토큰이 머터리얼 디자인에 적용되어 있다면 머터리얼 디자인을 상속한 다른 자식 프로젝트 디자인 또한 일관된 정보로 내려줄 수 있어 프로세스를 저동으로 문서화시킬 수도 있다고 생각한다.   






