---
title: Storybook으로 공통 모듈 컨벤션 만들기
date: 2022-12-26T00:00
tags: [reactjs, storybook, rollup]
publish: false
image: "."
---

사내에서 공통 모듈만 모아둔 라이브러리를 Storybook을 이용해 만들었는데 급하게 만들다보니 번들하고 배포하는 과정에서 아쉬운 부분이 보여 사이드 프로젝트를 진행하며 조금 더 공부해 본 내용을 정리하려고 한다.

# 1. Storybook을 사용하려는 이유
1. 자주 사용하는 코드만큼은 **문서화**시켜놓고 싶다.   
코드에 대한 간략한 명세서가 있다면 다른 사람이 해당 코드를 봤을 때 이해가 쉬울 것 같다.

2. 자주 사용하는 코드는 **공통 라이브러리**로 묶어놓고 싶다.   
프로젝트의 개수는 쌓여가지만 그 안에 활용하는 코드 및 기능은 동일한데 이 코드들이 프로젝트별로 각각 다르다면 유지보수할 때 너무 힘들 것 같다.

3. 코드 뿐만 아니라 **디자인 또한 모듈화**시키고 싶다.   
팀 특성상 프론트개발자가 곧 디자이너이기도해서 프론트의 코드와 디자인이 일체화되었으면 좋겠다는 생각에 도입했는데 사실 이 부분은 유연하게 가져가도 좋을 것 같다. (프로젝트마다 디자인이 작게 작게 변할 수도 있으니까) 당장 급한 것은 기능들을 모듈화시키는 것이고 디자인적인 부분에서 공통화시킬 개념은 색상값 정도로 생각하고 있다.

# 2. simple-design-kit✨ 초기 설정

해당 프로젝트는 컴포넌트 명세서 & 공통 모듈들을 라이브러리화시키는 용도이므로 모든 종속성 설치 라이브러리에 대해 짚고 넘어가며 만들기 위해 CRA 로 만들지 않았다. 

## package.json 파일 만들기

> package.json ?   
> 현재 프로젝트에 대한 정보(이름, 버전, 설명, 저자, 라이센스 종류 등)와 패키지 매니저(npm, yarn)을 통해 설치한 의존성 모듈들로는 무엇이 있는지 관리해 주는 파일이다.

```
npm init --yes
```

# 3. 컴포넌트 구성에 필요한 설치

npm 혹은 yarn 패키지 매니저를 통해서 package.json에 내가 만들고자하는 프로젝트에 필요한 의존성 모듈(라이브러리)들을 설치할 수 있는데 `-dev`, `-D` 옵션을 추가할 수 있다. 이 옵션을 추가하면 프로젝트의 개발 모드에서만 설치되는 `devDependencies` 리스트로 기재되어 실제 배포할 때 가벼운 버전의 프로젝트로 빌드할 수 있다.   
(내가 설치하는 라이브러리가 개발모드에서만 필요한지 배포모드에서도 필요한지 꼭 체크해서 날씬한 배포 프로젝트를 만들자) 

스토리북은 프론트 프레임워크 위에서 구동하는 UI 구성 요소용 개발 환경이다. 리액트를 예로 들자면 리액트 어플리케이션이 localhost:3000 에서 구동할 때 스토리북은 localhost:8000에서 단독으로 실행될 수 있다. 하지만 리액트도, 앵귤러도, 뷰도 없는 빈 프로젝트 위에서는 만들어지지 않는다. 그러므로 스토리북을 얹을 프론트 작업물이 선행으로 세팅되어야 한다.

```
npm install react react-dom @types/react -D
```
- react : 리액트 환경에서 사용할 컴포넌트가 필요하므로 리액트 라이브러리를 설치.
- react-dom : 리액트 라이브러리와 한쌍을 이루는 라이브러리로, 리액트를 위해 존재하는 돔의 진입 포인트 역할을 하는 라이브러리 설치.
- @types/react : 컴포넌트 코드들을 타입스크립트로 개발할 것이므로 리액트의 타입을 불러오는 라이브러리 설치
- typescript : 타입이 입혀진 컴포넌트를 개발할 예정이므로 타이핑 언어 설치.

```
// tsconfig.json
{
  "compilerOptions": {
    "declaration": true,
    "declarationDir": "build",
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "jsx": "react",
    "typeRoots": ["./types"]
  },
  "include": ["types"]
}
```
타입핑된 코드는 개발자 입장에서 친절하고 유용하지만 결국은 브라우저가 해석하기 위한 자바스크립트 코드로 컴파일되어야 한다. compilerOptions 에서 컴파일을 어떤 설정값으로 할지 세팅할 수 있고 include 에 들어간 값들은 타입스크립트의 컴파일러 대상 타겟이 된다. 타입을 지원하지 않는 써드파티 라이브러리의 경우 내가 직접 타이핑을 해줘야할 수도 있고 내가 만든 라이브러리 모듈에 특정 타입 코드가 반드시 들어가야하는 경우 활용하기 좋다.

compilerOptions 에 설정한 옵션값들을 하나씩 설명하면 다음과 같다.
`"declaration"`: 해당하는 코드의 .d.ts 파일을 생성한다. 내가 만든 컴포넌트들을 편집기에서 클릭하면 타입 정보 파일이 보였으면 하여 true로 설정했다.     
`"declarationDir"`: 프로젝트를 빌드시킬 폴더 경로를 지정한다.   
`"target"`: 컴파일될 자바스크립트 표준 규격 대상 버전 지정한다. 구버전의 브라우저도 지원할 수 있도록 es5로 지정했다.   
"lib": 컴파일에 포함될 라이브러리를 지정한다. //   
"skipLibCheck": true, //   
"esModuleInterop": CommonJS와 ES 모듈 간의 내보내기 상호 운용성을 활성화한다.   
"allowSyntheticDefaultImports": true, //   
"strict": 엄격 유형 검사 모드로 켰다.  
"module": 생성되는 코드들의 모듈 타입 지정한다. //      
"moduleResolution": 생성되는 코드들을 누가 해석하는지 지정한다.     
"resolveJsonModule": true,//      
"jsx": jsx 코드 생성은 리액트가 하도록 지정한다.      
"typeRoots": ["./types"] 유형 정의를 포함할 폴더 목록을 지정한다.   