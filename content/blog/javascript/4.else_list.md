---
title: 기타 면접 주제
date: 2022-01-11
tags: ["javascript"]
publish: false
image: "./javascript.jpg"
---

## 바벨로더 vs ts로더

코드 트랜스파일러로 ts로더가 아닌 `바벨로더`를 사용한 이유는  
바벨에 타입스크립트 프리셋을 설정하면 ts에서 js로 트랜스 파일은 가능하지만, 바벨이 코드타입을 검사하진 않아서 js로의 트랜스파일 시간이 빨라진다고 판단해 바벨로더를 선택했다.  
대신 lint 파일에서 타입스크립트 규칙을 설정해 개발 중 타입 오류 체크가 되도록 세팅했다.

## requestAnimationFrame vs setInterval(setTimeout)

요소의 움직임이 모든 프레임에 반영되어야 부드럽게 동작한다.
requestAnimationFrame api의 콜백 함수는 `모니터 주사율 성능에 의존하기 때문에 보통 1초에 60번의 동작 보장`한다.
브라우저에서 리플로우나 리페인트 현상이 일어나 브라우저를 업데이트해야하는 경우, 브라우저가 `프레임 생성 초기 단계에 맞춰서 애니메이션 코드를 실행`해 애니메이션이 부드럽게 동작한다.

> requestAnimationFrame큐 내부의 태스크들가 실행된 후에, 화면 업데이트가 일어나서 사용자 입장에선 끊기는 현상 없이 부드러운 애니메이션을 볼 수 있다.

setInterval, setTimeout api의 콜백 함수는 주어진 타이머를 갖고 태스크큐에 들어간다.
콜스택이 비어있는 경우 콜스택으로 들어가 실행되는데, 콜스택에 다른 함수들이 쌓여있는 경우 개발자가 의도한대로 1초당 콜백함수가 호출된다는 보장이 없어 끊기는 현상이 일어날 수 있다.

> js엔진은 메모리힙과 콜스택으로 이루어져있다
> 메모리힙은 변수나 함수가 저장될 때 사용하는 공간이다.
> 콜스택은 함수가 실행되는 과정을 기억하기 위해서 사용되는 자료구조이다
> 자바스크립트가 동작하는 런타임 환경에서는 태스크큐와 마이크로태스크큐를 이용해서 비동기적인 처리가 가능하다
> 태스크큐는 한번에 하나씩만 가져오고, 마이크로태스크큐는 들어있는 모든 태스크가 빌때까지 가져온다
> 브라우저는 초당 60개의 프레임을 만드므로 16밀리세컨 간격으로 1프레임이 생성되는게 이상적이다.
> requestAnimationFrame 큐에 있는 콜백함수들은 언제 실행될지 모르지만 확실한건 브라우저가 업데이트되기 전에 호출이 된 다음 다음 화면을 업데이트 한다

## css transition

UI 요소의 간단한 전환의 경우 css 사용한다.
중지, 재개와 같은 컨트롤이 들어가는 효과에는 js 애니메이션을 사용한다.

동적으로 계속 움직이는 요소는 주변의 다른 요소와 독립되어야 해당 범위에서만 리플로우, 리페인트 과정이 일어난다.
여기서 리페인트가 일어나지 않는 css인 transfomm과 같은 속성을 이용한다면 합성 단계까지만 일어나는 최적화된 렌더링을 구현할 수 있다.

https://web.dev/css-vs-javascript/

## 자기소개

안녕하세요 저는 IT 보안 기업인 이스트시큐리티에서 DI LAB팀의 FE 개발자로 근무 중인 김수영입니다.

DI LAB 팀은 기술 개발 및 국책 사업을 수주하는 일을 하고 있고,  
저는 여기서 사업 요구사항에 해당하는 프론트 화면 기획 및 개발을 담당하고 있습니다.
#1. 주로 `reactjs`와 `typescript`를 활용해 웹UI를 개발을 하고 있고,
#2. 가장 최근 사업에서는 이전 사업 대비 코드량을 줄이고 api 호출 리소스를 절약해보자는 목표로 `리덕스툴킷`과 `리액트쿼리`를 적용해보았습니다.
#3. 공통으로 적용되는 소스들을 관리하기 위해 공통 컴포넌트 모듈을 개발해 동일한 작업을 줄였고, `피그마`를 활용해 컴포넌트 디자인 파일을 관리하고 있습니다.

이런 현재 직무 경험들을 통해서 더 큰 기업에서 역량을 발휘하고 싶어 지원하게 되었습니다.

## ✨ 과제 코드 리뷰

주어진 과제는 `reactjs`를 활용해 싱글페이지어플리케이션 형식으로 개발했다. 타입의 안정성을 보장하기 위해 `타입스크립트`를 적용했다.
`웹팩`을 이용해 파일들을 es6 모듈로 번들하고, 스타일 작업은 `tailwindcss`를 적용했다.
버튼, 인풋 박스와 같은 공통 코드들은 써드파티라이브러리로 만들어 불러와 개발했다.
폴더 구조는 루트의 package.json을 기준으로 설정 파일들은 동일한 위치에 두었고
자바스크립트 파일과 정적 리소스 파일은 src 하위에 두었다.
src 하위 폴더들은 역할에 따라 이름을 지어 생성했다.

- 상태를 관리하는 폴더와 페이지에 관여하는 폴더, 유효성 검사 코드와 같은 헬퍼 코드만 모아둔 유틸 폴더, 훅 관련 폴더로 나눴다.

전역에 필요한 상태는 각 페이지마다 필요한 상태가 뭔지 파악 후 선별해 리액트 컨텍스트 api를 활용해 초기값을 등록해놨다.
코드를 작성할 때 지키려고 했던 규칙은 페이지 파일마다 해당 페이지에 구현된 기능이 뭔지 알 수 있도록 handle 함수로 남겨두었고
세부적인 구현은 헬퍼 함수나 커스텀 훅 함수로 빼서 각각 헬퍼와 훅 폴더에 배치했다.

<!-- 준비화면 -->

요구사항의 범위 안에서만 입력값이 유효하도록 설정했고 조건이 맞다면 열행두더지수는 전역 상태로 저장된다
페이지 라우팅은 react-router-dom 라이브러리를 활용해 구현했고 여기에 private 라우터 기능을 추가해 해당 조건에 맞지 않은 페이지는 준비화면으로 돌아가도록 리다이렉트 설정했다.

<!-- 게임화면 -->

전역 상태에 열값이 존재하면 보여지는 화면이다.
게임하기를 누르면 두더지 애니메이션과 카운트 다운 애니메이션이 실행된다.

- 두더지 애니메이션

  - 애니메이션은 웹 api인 `requestAnimationFrame`을 활용했다
  - 1초가 지날때마다 콜백함수를 실행하는데 이 콜백함수의 역할은 중복없는 랜덤두더지 배열을 생성해주는 함수다
  - 배열을 두더지 id와 두더지 타입값으로 이루어진 객체로 저장되는데 두더지는 입력받은 값+1만큼 생성되고 그중에 1마리만 다른 타입 값을 부여해 변종두더지를 배치했다.
  - 두더지가 움직이는 모션은 굴의 id와 두더지 id가 같으면 클래스를 부여해 css transition으로 구현했다.

- 카운트다운 애니메이션

  - 애니메이션은 웹 api인 `requestAnimationFrame`을 활용했다
  - 카운트다운 애니메이션은 시작 시간을 인자로 받아 현재 시간 스탬프로 할당해 이전 시간 스탬프와의 간격이 1초인 경우 ui 상에 보여줄 카운트 수를 업데이트하여 구현했다.

- 애니메이션 함수들은 isPlaying이라는 인자를 받아 true인 경우에만 진행시켜 잠시 멈춤과 재개하기 기능을 구현했다.
- 그만하기를 누르면 게임화면에서 준비화면으로 이동이 되는데 이때 컴포넌트가 unmount되는 시점에 `cancelAnimationFrame` api를 활용해 애니메이션을 종료했다.

<!-- 점수화면, 랭킹화면 -->

> es6모듈은 파일 자체에서 독자적인 스코프를 제공
> 브라우저마다 http 요청 수의 제약이 있다. 이 요청 수를 줄이기 위해 많은 js 파일들을 압축시켜 한번에 호출하기 위해 웹팩 사용
> 웹팩으로 번들된 js들은 index.html에서 main.js 파일 하나로 추가된다.
> script 태그에 defer 속성이 붙으면 html 돔 생성을 중단하지 않고 백그라운드에서 실행된다. 돔처리가 끝나면 이후에 실행된다.
> 웹팩 이미지 파일은 에셋 모듈을 이용해 별도 파일로 내보내 url를 추출했다.

    - 게임 화면을 로드할 때 이미지를 url을 다운받는 시간에 빈 화면이 보이는 현상이 발생해 준비화면에서 이미지 url을 미리 등록시켜 빈화면이 보이는 현상을 개선했다.

> tailwindcss = 유틸리티우선 특성이 주는 장점

    - 클래스 이름 짓는데 시간을 아낄 수 있다
    - 스타일 파일로 갔다오는 스위치 비용을 아낄 수 있다
    - 인라인으로 불가능한 호버, 포커스와 같은 상태를 클래스로 가능하다
    - 배포 환경에서 실제 사용하는 스타일만 생성해 용량면에서 이점을 가져간다
    - 스타일 우선 적용에 twin.macro 플러그인을 활용해 뒤에 있는 클래스를 앞에 있는 클래스로 덮어쓰기 가능 (나중에 앎)

## 컨텍스트 api와 리덕스 비교 (과제에선 왜 useContext 사용?)

컨텍스크 api와 리덕스 둘다 전역에서 상태를 관리할 수 있게 해 주는 도구이다. 다만 컨텍스트 api는 리액트에서만 사용이 가능하고 리덕스는 리액트가 아닌 다른 곳에서도 사용이 가능하며 전역 상태관리 외에도 다양한 기능을 제공한다.

과제에서 컨텍스트 api만 사용한 이유는 단지 전역 상태 관리 기능만 필요했기 때문에 추가 라이브러리 설치 없이 구현할 수 있는 컨텍스트 api를 활용했다.

https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367

## 리덕스 구동방식

변경이 일어날 컴포넌트에서 액션 크리에이터 함수가 디스패치되어 액션 객체를 생성하고,
리듀서가 액션 객체와 전달 받은 상태값을 참조해 새로운 상태객체를 생성한다.
이 새로운 상태 객체가 스토어에 저장이 되어 컴포넌트에 내려주면서 상태값이 업데이트 된다.

## 리덕스 장단점은?

장점

1. 액션을 디스패치할 때마다 리덕스 데브 툴즈를 사용하면 디스패치된 이력이 남아 디버깅이 쉽다.
2. 전역으로 상태 관리를 할 수 있어서 컴포넌트의 깊이와 상관없이 데이터를 업데이트 할 수 있는 점이 유용했다.

단점

1. 기능 하나를 추가하기 위해서 추가되는 파일 및 코드량이 있는 편이다

## ✨ tailwindcss vs styled-component

## ✨ 리덕스와 리덕스툴킷의 차이? 어떻게 코드를 줄였는지

## ✨ 리액트쿼리

## ✨ 리액트의 장점? SPA 개발에 리액트를 선택한 이유?

페이지 전체를 리로드하지 않고 `화면의 부분만 업데이트되는 동작`은 `좋은 사용자 경험`을 가져올 수 있어 SPA 방식의 개발을 선호했고 리액트와 같은 라이브러리를 사용하면 블록 조립하듯 코드를 분할해 개발이 가능하다는 점과 방대한 커뮤니티와 꾸준한 업데이트 이력을 봤을 대 안정성있는 도구라 판단해 사용 중이다.

## 사용한 리액트 버전은? 18에서의 새로운 기능은 아는지?

## ✨ 공통 컴포넌트 모듈 번들러로 롤업을 선택한 이유?

## 리액트에서 JSX 문법이 어떻게 사용되는지?

## ✨ NGINX 준비

## ✨ DOCKER 준비

✔ 기타

## 카카오페이 계열사 서비스 중에 아는 건?

## 최근 경험했던 기억에 남는 에러?

## 요즘 공부하고 있는 것?

## 이 분야 선택 이유(왜 개발자?)

## 새로운 기술 습득은 어떤 방식으로?

## 업무적으로 내가 가장 감명받았던 경험이나 크게 성장했던 경험 또는 평가자가 혹시라도 모를 수 있는 나만의 경험

## 본인이 생각했을 때는 A라는 방법으로 진행하면 안되는데, 위에서 A라는 방법으로 하라고 지시가 내려온 경우 어떻게 하실건가요?

## 백엔드 개발자와 협업한 경험이 있나요? 협업을 위해 어떤 프로그램을 사용했나요?

## 질문

Q. 현재 재직 중인 회사에 어떤 점을 가장 만족하며 다니는지
Q. 회사에서 조직원의 업무 능률을 올리기 위해 교육 프로그램 같은 것들이 따로 있는지

## 정리 안 된 것들

Esbuild는 여전히 빌드 중에 Vite에서 변환 및 축소에 사용되지만 번들링은 롤업에 남아 있습니다. 따라서 esbuild는 빌드 프로세스의 일부로 사용

### (생략)초안

(생략: 가장 최근에 담당한 사업으로는 한국인터넷진흥원에서 주최한 "URL 모니터링 웹사이트 2차" 사업입니다.)  
(생략: 해당 사업은 보안 관제 인력이, 의심이 가는 url를 대상으로 모니터링할 수 있고 함께 납품된 분석기를 통해 URL 분석 결과 화면을 조회할 수 있는 서비스를 제공합니다.)

(생략: 1차 사업 때 "리덕스"를 활용해 상태관리를 하였는데, 기능이 추가될 때마다 코드량이 늘어나는 점을 보완하기 위해
2차 사업 때는 리덕스 툴킷과 "리액트 쿼리"를 부분 도입했습니다
전역에서 필요한 상태는 리덕스로, api 호출에 연관돼 업데이트가 많은 상태들은 리액트쿼리로 분리했습니다.
이 결과 리덕스에 해당하는 "비동기" 코드량을 전과 대비 절반 이상 가량 줄일 수 있었고 리액트 쿼리에서 제공하는 반복 호출 캐싱 기능을 사용해 api 호출 리소스도 절약할 수 있었습니다.)

(배포는 리액트 빌드 결과물을 "nginx"로 실행하는 도커 파일을 공유해 쿠버네티스 환경에서 배포합니다. nginx로 배포하는 프로세스가 적힌 "도커" 파일까지만 제 작업선이고 함께 작업하는 PM 개발자분께서 배포를 진행하는 프로세스입니다.)

현재는 3차 사업을 준비하고 있습니다.
2차 때 리액트쿼리로 변환 못한 부분들의 마이그레이션을 마저 진행할 예정이고,
작업물의 빌드 속도 개선이 필요하다 판단해 순차적인 테스트를 거쳐 빌드 환경을 개선하고 있습니다.
(생략: 1. CRA 보일러프로젝트 기반인 1,2차 환경에서 CRA 없이 "웹팩" 번들러로 직접 설정해 최소한으로 꼭 필요한 환경 설정들을 스터디하고 2. 이후 "Vite" 번들러로 마이그레이션을 목표하고 있습니다)
