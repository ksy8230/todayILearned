---
title: 기타 면접 주제
date: 2022-01-11
tags: ["javascript"]
publish: false
image: "./javascript.jpg"
---

## 바벨로더 vs ts로더

코드 트랜스파일러로 ts로더가 아닌 `바벨로더`를 사용한 이유는  
바벨에 타입스크립트 프리셋을 설정하면 ts에서 js로 트랜스 파일은 가능하지만, 바벨이 코드타입을 검사하진 않아
서 js로의 트랜스파일 시간이 빨라진다고 판단해 바벨로더를 선택했다.  
대신 lint 파일에서 타입스크립트 규칙을 설정해 개발 중 타입 오류 체크가 되도록 세팅했다.

## requestAnimationFrame vs setInterval(setTimeout)

rAF와 setTimeout의 가장 큰 차이점은 1프레임 당 호출이 보장되느냐 되지 않느냐의 차이에 있다.

모든 프레임에 요소의 움직임이 반영되어야 부드럽게 동작한다.
requestAnimationFrame api의 콜백 함수는 `모니터 주사율 성능에 의존하기 때문에 보통 1초에 60번의 동작 보장`한다.
브라우저에서 리플로우나 리페인트 현상이 일어나 브라우저를 업데이트해야하는 경우, 브라우저가 `프레임 생성 초기 단계에 맞춰서 애니메이션 코드를 실행`해 애니메이션이 부드럽게 동작한다.

> requestAnimationFrame큐 내부의 태스크들가 실행된 후에, 화면 업데이트가 일어나서 사용자 입장에선 끊기는 현상 없이 부드러운 애니메이션을 볼 수 있다.

setInterval, setTimeout api의 콜백 함수는 주어진 타이머를 갖고 태스크큐에 들어간다.
콜스택이 비어있는 경우 콜스택으로 들어가 실행되는데, 콜스택에 다른 함수들이 쌓여있는 경우 개발자가 의도한대로 1초당 콜백함수가 호출된다는 보장이 없어 끊기는 현상이 일어날 수 있다.

> js엔진은 메모리힙과 콜스택으로 이루어져있다
> 메모리힙은 변수나 함수가 저장될 때 사용하는 공간이다.
> 콜스택은 함수가 실행되는 과정을 기억하기 위해서 사용되는 자료구조이다
> 자바스크립트가 동작하는 런타임 환경에서는 태스크큐와 마이크로태스크큐를 이용해서 비동기적인 처리가 가능하다
> 태스크큐는 한번에 하나씩만 가져오고, 마이크로태스크큐는 들어있는 모든 태스크가 빌때까지 가져온다
> 브라우저는 초당 60개의 프레임을 만드므로 16밀리세컨 간격으로 1프레임이 생성되는게 이상적이다.
> requestAnimationFrame 큐에 있는 콜백함수들은 언제 실행될지 모르지만 확실한건 브라우저가 업데이트되기 전에 호출이 된 다음 다음 화면을 업데이트 한다

## css transition

- 메인 쓰레드가 아닌 별도의 컴포지터 쓰레드에서 그려지기 때문에 메인 쓰레드에서 작업하는 JS보다 효율적

UI 요소의 간단한 전환의 경우 css 사용한다.  
중지, 재개와 같은 컨트롤이 들어가는 효과에는 js 애니메이션을 사용한다.

동적으로 계속 움직이는 요소는 주변의 다른 요소와 독립되어야 해당 범위에서만 리플로우, 리페인트 과정이 일어난다.
여기서 리페인트가 일어나지 않는 css인 transfomm과 같은 속성을 이용한다면 합성 단계까지만 일어나는 최적화된 렌더링을 구현할 수 있다.

> top의 값이 0px -> 100px로 1초동안 점차 증가하는 방식으로 애니메이션이 동작할때 top의 값이 1px씩 증가 할때 마다 메인쓰레드는 레이아웃과 페인팅을 새로해서 비트맵을 만들고 해당 비트맵을 컴포지터 쓰레드로 업로드 하며, 컴포지터 쓰레드는 이 비트맵을 로드하여 화면에 새로 그리는 작업을 반복
> transform의 translateY값을 0px -> 100px로 1초동안 점차 증가하는 방식으로 애니메이션이 동작할 경우에는 최초 해당 엘리먼트에 대한 비트맵이 업로드 된 이후로는 해당 비트맵 업로드 없이 컴포지터 쓰레드가 기존의 비트맵을 가지고 위치를 1px씩 이동시키는 작업을 반복

https://web.dev/css-vs-javascript/

<!-- 카카오페이의 보험 사업은 크게
보험대리점(GA)인 KP보험서비스와 디지털손해보험사인 카카오페이손해보험 -->
<!-- 12월에 온라인범죄예방을 위한 금융안심보험 -->

## ✨ 과제 코드 리뷰

과제 진행 전에,
화면별로 필요한 데이터들이 무엇인지 파악해보았다.
전역에서 필요한 데이터가 보여 이 상태들은 `context api`를 활용해 전역으로 빼두었고
공통으로 사용되는 ui는 `스토리북`과 `rollup`을 활용해 라이브러리화시켜 관리하고자했다.
스타일 작업은 배포 용량과 개발 생산면 우수한 `tailwindcss`를 선택했고,
브라우저 성능을 고려해 카운트다운이나 두더지 움직임 같은 애니메이션 기능이 들어가는 부분은 `requestAnimationFame`, `css transition`을 활용했다.

---

주어진 과제는 `reactjs`를 활용해 싱글페이지어플리케이션 형식으로 개발했다. 타입의 안정성을 보장하기 위해 `타입스크립트`를 적용했다.
`웹팩`을 이용해 빌드와 번들 작업을 진행했고, 스타일 작업은 `tailwindcss`를 적용했다.
버튼, 인풋 박스와 같은 공통 코드들은 써드파티라이브러리로 만들어 불러와 개발했다.
폴더 구조는 루트의 package.json을 기준으로 설정 파일들은 동일한 위치에 두었고
자바스크립트 파일과 정적 리소스 파일은 src 하위에 두었다.
src 하위 폴더들은 역할에 따라 이름을 지어 생성했다.

- 상태를 관리하는 폴더와 페이지에 관여하는 폴더, 유효성 검사 코드와 같은 헬퍼 코드만 모아둔 유틸 폴더, 훅 관련 폴더로 나눴다.

전역에 필요한 상태는 각 페이지마다 필요한 상태가 뭔지 파악 후 선별해 리액트 `컨텍스트 api를 활용`해 초기값을 등록해놨다.
코드를 작성할 때 지키려고 했던 규칙은 페이지 파일마다 해당 페이지에 구현된 기능이 뭔지 알 수 있도록 handle 함수로 남겨두었고
세부적인 구현은 헬퍼 함수나 커스텀 훅 함수로 빼서 각각 헬퍼와 훅 폴더에 배치했다.

<!-- 준비화면 -->

요구사항의 범위 안에서만 입력값이 유효하도록 설정했고 조건이 맞다면 열행두더지수는 전역 상태로 저장된다
페이지 라우팅은 react-router-dom 라이브러리를 활용해 구현했고 여기에 private 라우터 기능을 추가해 해당 조건에 맞지 않은 페이지는 준비화면으로 돌아가도록 리다이렉트 설정했다.

<!-- 게임화면 -->

전역 상태에 열값이 존재하면 보여지는 화면이다.
게임하기를 누르면 두더지 애니메이션과 카운트 다운 애니메이션이 실행된다.

- 두더지 애니메이션

  - 애니메이션은 웹 api인 `requestAnimationFrame`을 활용했다
  - 1초가 지날때마다 콜백함수를 실행하는데 이 콜백함수의 역할은 중복없는 랜덤두더지 배열을 생성해주는 함수다
  - 배열을 두더지 id와 두더지 타입값으로 이루어진 객체로 저장되는데 두더지는 입력받은 값+1만큼 생성되고 그중에 1마리만 다른 타입 값을 부여해 변종두더지를 배치했다.
  - 두더지가 움직이는 모션은 굴의 id와 두더지 id가 같으면 클래스를 부여해 css transition으로 구현했다.

- 카운트다운 애니메이션

  - 애니메이션은 웹 api인 `requestAnimationFrame`을 활용했다
  - 카운트다운 애니메이션은 시작 시간을 인자로 받아 현재 시간 스탬프로 할당해 이전 시간 스탬프와의 간격이 1초인 경우 ui 상에 보여줄 카운트 수를 업데이트하여 구현했다.

- 애니메이션 함수들은 isPlaying이라는 인자를 받아 true인 경우에만 진행시켜 잠시 멈춤과 재개하기 기능을 구현했다.
- 그만하기를 누르면 게임화면에서 준비화면으로 이동이 되는데 이때 컴포넌트가 unmount되는 시점에 `cancelAnimationFrame` api를 활용해 애니메이션을 종료했다.

<!-- 점수화면, 랭킹화면 -->

> es6모듈은 파일 자체에서 독자적인 스코프를 제공
> 브라우저마다 http 요청 수의 제약이 있다. 이 요청 수를 줄이기 위해 많은 js 파일들을 압축시켜 한번에 호출하기 위해 웹팩 사용
> 웹팩으로 번들된 js들은 index.html에서 main.js 파일 하나로 추가된다.
> script 태그에 defer 속성이 붙으면 html 돔 생성을 중단하지 않고 백그라운드에서 실행된다. 돔처리가 끝나면 이후에 실행된다.
> 웹팩 이미지 파일은 에셋 모듈을 이용해 별도 파일로 내보내 url를 추출했다.

    - 게임 화면을 로드할 때 이미지를 url을 다운받는 시간에 빈 화면이 보이는 현상이 발생해 준비화면에서 이미지 url을 미리 등록시켜 빈화면이 보이는 현상을 개선했다.

> tailwindcss = 유틸리티우선 특성이 주는 장점

    - 클래스 이름 짓는데 시간을 아낄 수 있다
    - 스타일 파일로 갔다오는 스위치 비용을 아낄 수 있다
    - 인라인으로 불가능한 호버, 포커스와 같은 상태를 클래스로 가능하다
    - 배포 환경에서 실제 사용하는 스타일만 생성해 용량면에서 이점을 가져간다
    - 스타일 우선 적용에 twin.macro 플러그인을 활용해 뒤에 있는 클래스를 앞에 있는 클래스로 덮어쓰기 가능 (나중에 앎)

## 페이지 단위로 구성한 이유?

라우터 파일을 구성할 때 페이지 단위로 나눠야했고
상태관리를 설계할 때 페이지를 기준으로 데이터를 선정해 페이지를 기준으로 구성하게 되었다.

## 컴포넌트로 빼는 기준?

재사용성이 있는 컴포넌트의 경우 폴더로 따로 빼고
페이지 코드가 길어져서, 혹은 가독성에 문제가 생겨 코드를 분할해야할 때 컴포넌트 폴더로 빼는 편입니다.

페이지 폴더에 따로 컴포넌트 폴더를 두지 않는 이유는 추후에 nextjs로의 마이그레이션 작업을 고려해 이와 같은 폴더 구성을 했다.

## ✨ 컨텍스트 api와 리덕스 비교 (과제에선 왜 useContext 사용?)

컨텍스크 api와 리덕스 둘다 전역에서 상태를 관리할 수 있게 해 주는 도구이다. 다만 컨텍스트 api는 리액트에서만 사용이 가능하고 리덕스는 리액트가 아닌 다른 곳에서도 사용이 가능하며 전역 상태관리 외에도 다양한 기능을 제공한다.

과제에서 컨텍스트 api만 사용한 이유는 단지 전역 상태 관리 기능만 필요했기 때문에 추가 라이브러리 설치 없이 구현할 수 있는 컨텍스트 api를 활용했다.

복잡한 전역 상태 관리를 해야 할 때 ContextAPI는 Context가 공급하는 value가 변경되면 해당 Context에 속하는(ContextProvider 컴포넌트의 자식인) 컴포넌트들이 모두 리렌더 됩니다.
반면 Redux는 스토어의 특정 값이 변화하였을 때 해당 값을 구독하고 있는 컴포넌트만 리렌더가 발생합니다.
물론 Context를 사용할 때에도 Context 분리, useCallback, useMemo, React.memo으로도 Redux와 동일한 급의 최적화가 가능하지만 그 정도로 최적화가 필요하고 복잡한 상태관리가 필요하다면 Redux가 현명한 대안

https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367

## 리덕스 구동방식

변경이 일어날 컴포넌트에서 액션 크리에이터 함수가 디스패치되어 액션 객체를 생성하고,
리듀서가 액션 객체와 전달 받은 상태값을 참조해 새로운 상태객체를 생성한다.
이 새로운 상태 객체가 스토어에 저장이 되어 컴포넌트에 내려주면서 상태값이 업데이트 된다.

## 리덕스 장단점은?

장점

1. 리덕스의 데브 툴즈를 사용하면 디스패치된 이력이 남아 디버깅이 쉽다.
2. 전역으로 상태 관리를 할 수 있어서 컴포넌트의 깊이와 상관없이 데이터를 업데이트 할 수 있는 점이 유용했다.

단점

1. 기능 하나를 추가하기 위해서 추가되는 파일 및 코드량이 있는 편이다

## ✨ tailwindcss vs styled-component

현업에서는 styled-component를 사용했고 개인적으로는 tailwindcss를 사용해봤는데 코드가 깔끔하게 정리되는 느낌에서는 styled-component가 좋았고
생산적인 측면에서는 tailwindcss가 우수했다고 생각한다. 특히 머터리얼 ui 라이브러리와 비교했을 때 이미 정해진 디자인 컴포넌트를 활용하는 프레임워크가 아닌 유틸리티 클래스 작성법이라 커스터마이징이 많은 현업에 적합하다고 생각했다.
성능적인 측면에서도 styled-component가 css 역할을 하기 위해선 자바스크립트 코드 해석 시간이 들어가는데  
tailwind는 이미 존재하는 클래스를 가져다 사용하는 방식이고, 배포 때는 사용하지 않는 css들을 알아서 제거해주는 purgecss라는 내장 라이브러리가 존재해 유틸리티 클래스들의 용량을 줄여준다는 이점이 있어 현업에도 도입 준비 중에 있습니다.

postcss : css를 모듈화시켜서 사용할 수 있는 라이브러리
styled-component : 자바스크립트 안에서 css를 사용할 수 있는 라이브러리  
tailwindcss : 유틸리티 클래스 이름으로 사용할 수 있는 css를 사용할 수 있는 라이브러리

styled-component 장점

- 태그가 있는 템플릿 리터럴을 사용해서 css구문을 js로 변환한다
- 이때 js 함수처럼 css prop을 내려줄 수 있어 상태값에 따른 스타일 적용이 편했고 코드가 직관적이다
- 태그명에 대한 네이밍 패턴이 있다면 스타일이 적용된 코드 자체는 깔끔하다고 생각한다

> 돔 노드의 헬퍼 메서드 집합을 이용해 템플릿 리터릴이 사용 가능하다

styled-component 단점

- 자바스크립트로 생성된 css는 css 모듈 방식보다 브라우저에서 렌더링 속도가 느려질 수 있다.
  - css 모듈 방식은 css 파일이 추출되므로 자바스크립트 해석 시간이 따로 들지 않아 속도가 더 빠르다

tailwindcss 장점

- 정해진 클래스들을 활용하기 때문에 클래스 이름을 짓지 않아도 된다
- 배포 환경에서는 실제 사용하는 스타일만 존재한다

tailwindcss 단점

- 정해진 클래스들이 있어서 이걸 익히는 소요 시간이 든다
- 클래스명을 나열하는 방식이라 가독성이 떨어질 수 있다

styled-component 동작방식: https://www.zigae.com/styled-components-abstract/
https://daily.dev/blog/why-i-moved-from-styled-components-to-tailwind-css-and-whats-the-future-of-css-in-js

## ✨ 리액트쿼리

`서버 상태에 의존하는 비동기 데이터를 업데이트할 때 유용한 라이브러리이다.`

리액트쿼리 동작 방식:  
리액트쿼리 api를 사용하면 쿼리별로 첫번째 인자에 키값을 제공한다. 네트워크 통신별로 각각 고유한 키가 해시값으로 생성되고 이 키 이름 아래에, 데이터를 메모리에 보관한다. 두번째 인자에 async나 promise를 이용해 비동기 호출 함수를 넣어두면 리턴값으로 호출 결과를 반환시킨다. 세번째 인자로 옵션을 전달할 수 있다.
기본적으로 따로 설정을 하지 않으면 stale 시간은 0, 캐시 시간은 5분이다.
ui에서 쿼리를 요청했을 때 해당 키 상태가 stale인 경우 일단 저장된 캐시 정보를 보여주고 서버로 재호출을 해 캐시 데이터를 업데이트한다. 만약 업데이트된 데이터가 이전과 다르다면 ui 화면에 업데이트가 일어나고 그렇지 않다면 ui 화면 업데이트가 일어나지 않는다

### 사용한 이유

캐싱과 동기화 기능 등을 제공하고 전역 상태와 서버 상태를 분리해 관리하기 위한 도구로 활용했다.
또한 생성된 쿼리별로 조회가 가능한 데브 툴을 제공한다.

    - 데브툴을 활용해 언제 마지막으로 캐시가 되었는지 쿼리의 현재 상태가 무엇인지 반환된 데이터는 뭔지 상세하게 조회 가능하다.

## ✨ 리액트의 장점? SPA 개발에 리액트를 선택한 이유?

페이지 전체를 리로드하지 않고 `화면의 부분만 업데이트되는 동작`은 `좋은 사용자 경험`을 가져올 수 있어 SPA 방식의 개발을 선호했고 리액트와 같은 라이브러리를 사용하면 `블록 조립하듯 코드를 분할해 개발`이 가능하다는 점과 `방대한 커뮤니티`와 `꾸준한 업데이트` 이력을 봤을 대 `안정성있는 도구`라 판단해 사용 중이다.

## ✨ 리덕스와 리덕스툴킷의 차이?

`리덕스 툴킷: 리덕스에서 자주 쓰는 기능들을 모두 모아둔 라이브러리이다.`

0. 리덕스를 사용하기 위해 설치했던 패키지의 양도 적다.

1. 액션 함수, 액션 타입, 리듀서 파일 작성을 createSlice 함수로 묶을 수 있어서 리덕스 대비 코드량을 많이 줄일 수 있었다.

2. 스토어 설정 축소

- 기존에는 스토어를 설정할 때 루트 리듀서를 생성해 리듀서들을 묶어서 스토어에 연결해줘야했다면 리덕스 툴킷에서는 스토어 configureStore() api를 사용할 때 리듀서를 묶는 작업을 따로 지정하지 않아도 된다.

## 어떻게 코드를 줄였는지

<!-- 1. `리덕스 툴킷: 리덕스에서 자주 쓰는 기능들을 모두 모아둔 라이브러리이다.` -->

<!-- 2. `리액트쿼리: 서버 상태에 의존하는 비동기 데이터를 업데이트할 때 유용한 라이브러리이다.` -->

## 리액트 쿼리

- 서버 상태에 의존하는 비동기 데이터를 업데이트할 때 유용한 라이브러리이다
- 선택이유: 심층 URL 프로젝트는 서버 데이터에 의존하는 화면이 많기 때문에 라이브러리 도움을 받아 안정적인 데이터 업데이트를 위해 선택했다.

  - 연속된 동일한 호출에 대해서는 1번만 호출을 시킨다
  - 사용자가 설정한 초 이후에는 낡은 데이터라 판단해 재호출을 시도한다 => 대시보드 자동 업데이트 기능 유용
  - 데이터 변경점이 있는 경우에는 화면을 리렌더링 => 기존에 api 호출 응답을 확인하기 위해 사용한 호출 보조용 상태들이 더 필요 x
  - 리덕스의 비동기 호출 코드를 리액트 쿼리로 빼면서 => 서버 데이터 / 클라이언트 데이터 나눔 => 리덕스 = 본연의 역할을 할 수 있는 순수 상태관리자 만들다

## ✨ 공통 컴포넌트 모듈 번들러로 롤업을 선택한 이유?

라이브러리로 번들시킬 도구를 고를 때 고려했던 사항은  
빌드된 용량이 가벼웠으면 좋겠고  
라이브러리를 가져다 쓸 때 필요한 코드만 가져올 수 있으면 좋겠다고 생각했다

롤업은

1. es모듈로 빌드가 가능해서 import 문을 사용해, 필요한 함수만 가져올 수 있고
2. 코드를 import 문으로 가져올 때 사용되지 않는 코드는 제외해서 용량적인 측면에서도 충족했다
   그 외에도
3. 작업 폴더 구조를 빌드 폴더 구조로 옮길 수 있어서 빌드된 결과물 확인이 쉽다
4. es모듈 뿐만 아니라 commonjs로의 빌드도 가능해 라이브러리의 호환성도 챙길 수 있다 생각했다

## webpack5 vs rollup

`웹팩`은 js 파일 외에도 image나 css같이 `번들시킬 파일이 많은 경우`와 `안정성`이 중요한 웹앱을 만들어야하는 경우 선호되고,  
`롤업`은 `코드 스플리팅` 면이 우수해 용량이 `작은 라이브러리를 만들 때 적합`하다고 생각한다.

## ✨ 현업에서 NGINX 사용한 이유

사업 프로젝트에서 진행했던 요구사항 중 정적 컨텐츠는 캐싱되어야한다는 항목이 있었다. 이 부분을 충족하기 위해서 리버스 프록시 서버의 역할로 nginx를 사용했다.

> 리버스 프록시 서버?  
> 클라이언트가 서버에게 요청을 하면, 서버에게 바로 통신이 가는 것이 아니라, 중간의 프록시 서버가 실제 웹 서버에게 요청을 하게 된다. 그러면 웹 서버의 응답을 프록시 서버가 받고 프록시 서버가 클라이언트에게 응답을 전달한다.  
> 이러한 방식으로 클라이언트는 실제 서버의 위치는 모르기 때문에 보안성이 뛰어나며, 정적 파일을 전송할 때도 프록시 서버의 캐싱된 파일로 바로 전송 가능하다
> Nginx 는 하나의 master process 와 여러 worker process 로 구성

## SSL(TLS)에 대한 전반적인 설명

`데이터`를 암호화하는 데 사용되는 `암호화 프로토콜`이다.  
공개 키 암호화를 사용한다.

SSL(TLS) 동작 방식

서버와 클라이언트가 실제 데이터를 주고 받기 전에 `핸드세이크`를 거쳐, 서버와 클라이언트가 서로 존재하는지 확인하고 데이터를 주고 받는 방법을 파악한다

**핸드세이크 순서**

1. 클라이언트측에서 랜덤한 데이터와 클라이언트가 지원하는 암호화 방식을 서버에게 전달한다
2. 서버는 응답으로 서버에서 생성한 랜덤한 데이터와 서버가 선택한 클라이언트의 암호화 방식을 클라이언트에게 전달한다 그리고 이때 인증서도 같이 전달한다
3. 클라이언트는 서버가 준 인증서가 올바르게 발급된 것인지 확인하고 인증서를 복호화한다. 복호화에 성공하게 되면 이 절차를 통해 클라이언트는 서버를 신뢰한다.

> HTTPS = SSL을 통한 HTTP
> SSL 인증서 : 서버에서 호스팅되는 작은 텍스트 파일로 htt
> 비대칭키 암호화: 두 개의 키로 암호화와 복호화를 하는 암호화 방식

## https에 대한 개념

`브라우저`에서 사용하는 `보안 버전의 http 프로토콜`이다.  
http 프로토콜로 검색된 데이터를 암호화해서 서버간에 오가는 데이터를 제3자가 읽을 수 없게 한다.
https는 암호화 알고리즘을 사용해 암호화를 시킨다.

> http: 브라우저에서 웹사이트간의 정보를 교환하는데 사용하는 프로토콜

## HTTP 헤더값 중 connection의 keep-alive 속성

http 헤더에 keep-alive라는 값을 주면 서버와 클라이언트의 커넥션을 재활용한다

## HTTP 응답코드 200, 300, 400, 500번대별 설명

## ✨ 현업에서 DOCKER 사용한 이유

1. 도커 이미지를 만들어두면 작업한 환경을 패킹할 수 있어서 다른 팀원의 컴퓨터에서 쉽게 구동시킬 수 있는 장점이 있다.
2. 도커 이미지 자체가 프론트 배포 환경 명세서가 된다는 점도 좋았고
3. 리액트 웹어플리케이션의 최종 배포 환경이 쿠버네티스였다
   - 쿠버네티스에 앱을 배포하기 위해선 컨테이너로 패키징이 필요했다
   - 도커로만 많은 서버의 자원들을 관리하기 어려워 쿠버네티스를 도입한 걸로 안다

하이퍼바이저  
: 하나의 컴퓨터에서 다양한 운영체제 환경에서 프로그램을 구동해야할 때 사용
게스트os  
: 하이버바이저 같은 virtual machine에 설치된 운영체제
호스트os  
: 실제 구동 중인 컴퓨터의 운영체제
**도커**  
: 하이퍼바이저와 같은 virtual machine에서 게스트 os를 뺀 개념으로 환경파일을 갖추고 그 위에 앱을 실행시킬 수 있는 컨테이너 기술
**도커레지스터리(도커허브)**  
: 도커 이미지들을 모아둔 저장소
**쿠버네티스**  
: 도커 컨테이너들을 관리할 수 있는 도구
**쿠버네티스 클러스터**  
: 컨테이너 형태의 어플리케이션을 호스팅하는 노드들로 이루어진 집합  
**파드**
: 컨테이너들을 하나 이상 모아놓은 집합으로 노드 안에 존재  
파드 < 노드 < 클러스터

## ✨ 도전적인 이슈 혹은 버그 경험

사업 프로젝트로 개발한 페이지 중 데이터 결과에 따라 대량의 데이터를 로드해야할 일이 있었고 이 경우 로딩 속도가 5초 이상나는 이슈가 있었다.

`크롬 개발자 도구의 성능 탭`을 이용해 로딩이 지연되는 컴포넌트들을 발견했고
react 라이브러리에서 제공하는 `메모라이제이션 api`를 활용해 `반복되는 함수를 재활용`시켰고
하위 구성요소가 많은 컨텐츠를 불러올 때는 `Lazy-Loading`을 활용해 `개별 자바스크립트로 분할`시켜 첫 페이지를 로드하는 main.js의 부담을 줄이고자 했다

로딩이 오래 걸렸던 `해당 컨텐츠의 본래 목적`이 `분석된 url 중 악성으로 탐지한 url이 뭔지 확인`하는 컨텐츠라는 점에 초점을 둬서 분석된 url을 전부 로드하는 것이 아니라 악성 태그를 갖고 있는 url만 화면상에서 먼저 보여주는 방식으로 ui 기획을 수정했다.

수정 이후 로딩 속도를 3초내로 개선.

> 2차 분석기 개수:
> 사업 요구사항 조건은 분석기 서버 1대당 1일에 최소 700만개 이상의 url을 크롤링해야한다
> 시간당 평균 40만개의 url이 분석되어 결과값을 처리하는 환경이었다
> 링크트리의 개수 많은 경우 1000개

합성 함수

## XSS (크로스사이트 스크립팅)

웹사이트에서 악의적인 목적을 가진 `제 3자가 스크립트를 삽입해` `피해자의 정보를 탈취`할 수 있는 취약점이다.

## CSRF

악의적인 목적을 가진 `제 3자가 피해자의 권한을 도용`해 `특정 웹사이트에 요청`하는 공격 방식이다.

- 악성 메일 열람하면 피해자가 의도하지 않게 특정 사이트에 요청

## 보안을 고려하여 코딩했던 경험 사례

1. `React DOM에서 JSX 문법`을 사용해 `크로스 사이트 스크립팅` 공격을 방지하려 했고,

   - React DOM은 JSX에 삽입된 모든 값을 렌더링하기 전에 문자열로 변환하는 작업을 해서

2. nginx를 프록시 서버로 설정해 백엔드 서버의 주소 위치를 한겹 숨겼고

3. CPS 정책(컨텐츠 보안 정책)을 사용해 웹 리소스들의 동일 출처 정책을 추가했다

   - add_header X-Frame-Options

https://yohanpro.com/posts/front-end-security

## ✨ 사이트 최적화하는 방법

1. `웹팩이나 vite같은 번들러`를 사용한다

- css 파일은 html 상단에, js 파일은 하단에서 불러온다
- 많은 파일들을 번들시켜 하나의 압축된 파일로 불러와 호출 리소스를 줄인다

2. DOM의 깊이를 되도록 얕게 구성하기 위해 컴포넌트를 구성할 때 자식의 자식 컴포넌트로 만들기보다는 `합성 컴포넌트`를 사용한다

3. `애니메이션 구현은 css`통해 구현다

- css를 활용하면 메인스레드가 아닌 컴포짓 스레드를 활용한다
- 단순 위치 이동은 positioning보다는 transform이 더 좋다.
- transform css 속성은 리플로우, 리페인트를 발생하지 않아 렌더링 속도를 향상할 수 있다.
- css 로드는 렌더링을 차단하므로 라이트하우스를 활용해 미사용 css를 확인. (2kb인 경우 체크됨)

4. Gzip 사용

5. 동일 리소스 요청의 경우 캐싱 적용
   - 첫 로딩시에 내려받은 리소스의 복사본을 저장하고 동일 리소스 요청이 오면 서버까지 재요청을 하는게 아니라 복사본을 사용해 로딩 속도 향상에 도움이 된다

## 빅데이터 기반으로 차트 개발시 고려 사항

1. canvas 기반으로 사용한다

   - 최종 화면에 렌더링되는건 canvas 하나이기 때문에 차트에 표현할 데이터(오브젝트)가 많아도 성능 저하가 심하지 않기 때문이다.

2. canvas에 width, height를 부여할 때 device pixel ratio(DPR) 배율로 계산한다.
   - 모니터마다 css로 1 픽셀을 그리는데 사용되는 픽셀 수가 다르기 때문이다.

> CSS 픽셀을 구성하는데 필요한 물리적 픽셀 수 = DPR (device pixel ratio)
> https://meetup.nhncloud.com/posts/297

## (미완) 리액트에서 JSX 문법이 어떻게 사용되는지?

React 라이브러리에서 createElement 함수를 이용해 태그와 값을 전달하면 바벨에서 해당 함수를

✔ 기타

## ✨ 심층 URL 보안 모니터링 웹 사이트 2차 사업은 어떤 것인가? 배포 프로세스 설명도 가능한가?

대량의 웹사이트들을 패턴 점검시켜 악성,의심,정상으로 나눠 모니터링할 수 있는 제품을 만드는 사업이었다.
자사가 갖고 있는 데이터를 가지고 AI로 학습시켜 나온 패턴이랑 넷스파이더라는 패턴 기반의 분석기를 이용해 점검한다.
여기에 고객사가 갖고 있는 패턴을 추가할 수 있는 인터페이스를 제공하는 방식이었다.

쿠버네티스를 이용해 웹사이트들을 분석시킬 분석기를 관리하고 웹 어플리케이션과 api 서버를 배포한다.

## 배포 프로세스

작업자의 컴퓨터에서 테스트 배포를 진행해본 다음,
작업물이 도커라이징된 파일을 내부 깃랩 서버에 업로드가 된다. 배포 역할을 맡은 개발자분께서 실제 서비스 환경과 똑같은 테스트 배포 환경에서 qa를 진행 후 후 실제 배포가 이루어진다.

배포 환경은 `쿠버네티스 환경`이고 `깃랩`에서 공유되는 `도커 파일`을 내려받아
쿠버네티스 마스터 노드에 도커 이미지를 업로드하면
해당 컨테이너와 연결된 팟이 업데이트 되는 방식이다.

제가 배포와 관련해서 진행했던 작업선은
리액트 빌드 파일을 정적 웹서버로 띄울 수 있는 도커 파일과
웹서버 앞단에 위치하는 프록시 웹서버를 띄울 수 있는 도커 파일을 작성하였고
정적 웹서버와 프록시 서버 둘 다 nginx를 사용해 배포했다.
이 두 컨테이너를 도커 네트워크를 이용해 연결시켰고
프록시 서버에 사용한 nginx 파일에서 img 확장자를 갖는 파일에 한해 캐싱을 시키고
/api 경로로 오는 요청은 장고 서버 주소로 보내주는 식으로 작성했다.

docker build -t react-vite .
docker run --network my-network --name react-vite-container react-vite
docker run --network my-network --link react-vite-container:reactjs --publish 3000:80 react-vite-proxy

## ✨ 요즘 공부하고 있는 것?

모던 JavaScript 튜토리얼이라는 자바스크립트 공부용 웹사이트를 한 챕터씩 읽고 있다.
그 외에는 사이드프로젝트를 진행하며 Nextjs로 아주 간단한 서비스를 띄우는 걸 목표로 만들어보고 있다.

## ✨ 이 분야 선택 이유(왜 개발자?)

내 작업의 결과물이 눈으로 바로 보이는 것에 흥미가 있고 살아가면서 자기 효능감을 주기적으로 느끼고 싶어하는 편인데 그 효능감을 느낄 수 있는 분야가 개발이었다.  
그리고 공부할 건 늘 많고 어려울 때고 있지만 깊게 더 알아갈 때마다 성취감을 느끼는 분야에서 일을 하고 싶어 선택했다.

## ✨ 새로운 기술 습득은 어떤 방식으로?

## 업무적으로 내가 가장 감명받았던 경험이나 크게 성장했던 경험 또는 평가자가 혹시라도 모를 수 있는 나만의 경험

## 본인이 생각했을 때는 A라는 방법으로 진행하면 안되는데, 위에서 A라는 방법으로 하라고 지시가 내려온 경우 어떻게 하실건가요?

## 백엔드 개발자와 협업한 경험이 있나요? 협업을 위해 어떤 프로그램을 사용했나요?

## 궁금한 점 질문

Q. 현재 재직 중인 회사에 어떤 점을 가장 만족하며 다니는지
Q. 회사에서 조직원의 업무 능률을 올리기 위해 교육 프로그램 같은 것들이 따로 있는지

## 정리 안 된 것들

Esbuild는 여전히 빌드 중에 Vite에서 변환 및 축소에 사용되지만 번들링은 롤업에 남아 있습니다. 따라서 esbuild는 빌드 프로세스의 일부로 사용

### (생략)초안

(생략: 가장 최근에 담당한 사업으로는 한국인터넷진흥원에서 주최한 "URL 모니터링 웹사이트 2차" 사업입니다.)  
(생략: 해당 사업은 보안 관제 인력이, 의심이 가는 url를 대상으로 모니터링할 수 있고 함께 납품된 분석기를 통해 URL 분석 결과 화면을 조회할 수 있는 서비스를 제공합니다.)

(생략: 1차 사업 때 "리덕스"를 활용해 상태관리를 하였는데, 기능이 추가될 때마다 코드량이 늘어나는 점을 보완하기 위해
2차 사업 때는 리덕스 툴킷과 "리액트 쿼리"를 부분 도입했습니다
전역에서 필요한 상태는 리덕스로, api 호출에 연관돼 업데이트가 많은 상태들은 리액트쿼리로 분리했습니다.
이 결과 리덕스에 해당하는 "비동기" 코드량을 전과 대비 절반 이상 가량 줄일 수 있었고 리액트 쿼리에서 제공하는 반복 호출 캐싱 기능을 사용해 api 호출 리소스도 절약할 수 있었습니다.)

(배포는 리액트 빌드 결과물을 "nginx"로 실행하는 도커 파일을 공유해 쿠버네티스 환경에서 배포합니다. nginx로 배포하는 프로세스가 적힌 "도커" 파일까지만 제 작업선이고 함께 작업하는 PM 개발자분께서 배포를 진행하는 프로세스입니다.)

현재는 3차 사업을 준비하고 있습니다.
2차 때 리액트쿼리로 변환 못한 부분들의 마이그레이션을 마저 진행할 예정이고,
작업물의 빌드 속도 개선이 필요하다 판단해 순차적인 테스트를 거쳐 빌드 환경을 개선하고 있습니다.
(생략: 1. CRA 보일러프로젝트 기반인 1,2차 환경에서 CRA 없이 "웹팩" 번들러로 직접 설정해 최소한으로 꼭 필요한 환경 설정들을 스터디하고 2. 이후 "Vite" 번들러로 마이그레이션을 목표하고 있습니다)
