## 이벤트 핸들러란?

## 이벤트 위임?

## setState로 상태 변화를 해야 하는 이유?

## ✨ (미완) 방통대 관련 cs 준비

[dfs 깊이우선탐색 알고리즘](https://gmlwjd9405.github.io/2018/08/14/algorithm-dfs.html)
[페이징/내부 단편화](https://jhnyang.tistory.com/290)

## ✨ 알고리즘 관련 -> 개선 방안 흐름으로 풀기

## 컴파일러는 뭐고 인터프리터는 뭔가요?

## 정확히 어떤 포트폴리오인지 세부 설명 준비 👇

## ✨ 심층 URL 보안 모니터링 웹 사이트 2차 사업은 어떤 것인가? 배포 프로세스 설명도 가능한가?

대량의 웹사이트들을 패턴 점검시켜 악성,의심,정상으로 나눠 모니터링할 수 있는 제품을 만드는 사업이었다.
자사가 갖고 있는 데이터를 가지고 AI로 학습시켜 나온 패턴이랑 넷스파이더라는 패턴 기반의 분석기를 이용해 점검한다.
여기에 고객사가 갖고 있는 패턴을 추가할 수 있는 인터페이스를 제공하는 방식이었다.

쿠버네티스를 이용해 웹사이트들을 분석시킬 분석기를 관리하고 웹 어플리케이션과 api 서버를 배포한다.

## ✨ 팀 내부 연구 과제용으로 활용할 플랫폼형 프로젝트

해당 사업의 목표는 아마존에서 사용하는 서비스들의 금액 사용량을 모니터링하고 같은 그룹 권한에 있는 사용자들의 ip를 조회해 로그를 확인할 수 있고 의심스러운 행위를 하는 ip를 차단하는 기능을 제공 제품을 만드는게 목표였는데
컨텐츠 자체가 다 정해지지 않은 초안 단계에서 중단된 상태이다.
컨텐츠가 정해지면 활용할 수 있도록 ui들만 미리 만들어놓은 프로젝트라고 이해하시면 될 것 같습니다.

## ✨ (미완) 서버와의 통신을 위해 고려할 점

- 데이터 관점
- http 프로토콜 관점

## ✨ 데이터 가공 처리가 필요한 이유?

api를 호출했을 때 해당 ui에 꼭 필요한 데이터만 줬으면 좋겠지만 프로젝트가 복잡하고 커져서 서버가 도메인 단위로 코드를 관리해야하는 경우 데이터가 브라우저에 렌더링되기 위한 가공이 필요하다.
예를 들어 프론트는 응답 받은 데이터리스트가 없는 경우의 조건식을 추가해 UI를 보여줘야하거나
응답받은 리스트들 중 악성 태그가 붙은 리스트만 보여줘야하는 경우 필터링을 시키는 작업과 같은 가공이 필요하다.

## ✨ 데이터 가공 처리 어떻게 했나?

이런 조건식을 추가하고 필터링 코드를 붙이는 작업 자체는 어렵지않지만
매 페이지마다 미묘하게 필요한 데이터들이 달라서 그때마다 가공처리 코드를 붙이는게 지저분하다 판단했다.

https://velog.io/@jjunyjjuny/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EA%B0%80%EA%B3%B5%ED%95%98%EB%9D%BC

### Class Instance로 변환

Class의 Instance를 활용해 가공 처리 작업을 개선해보았다.
Class를 활용하게 되면 데이터를 가공하는 책임을 해당 클래스에게 위임을 할 수 있어서 가공처리와 관련된 코드의 응집성이 높아진다.

예를 들어서 url 리스트에 관련된 가공 데이터가 필요한 경우 UrlData라는 클래스를 만들어 내부에 데이터리스트가 없는 경우 (getter 메서드를 활용해) isEmpty라는 프로퍼티를 만들어둔다. 그리고 외부에서 필요한 가공처리가 적용된 속성을 사용할 수 있도록 코드를 개선해본 경험이 있다.

1. 이렇게 되면 가공처리 코드가 여기저기에 산재되어있는게 아니라 한군데에 묶어서 관리할 수 있고,
2. UI를 렌더링하는 코드에선 가공처리로직이 빠지면서 view 역할에 집중할 수 있게 된다.
3. 서버의 API 응답 스키마가 확정되지 않은 상태라도 클라이언트에서 사용할 데이터의 인터페이스를 우선 정의해둘 수 있어서 API가 미완성일지라도 레이아웃 작업을 먼저 진행할 수 있다.
   - 4. 나중에 API에서 내려준 데이터가 달라져도 view단은 건드릴 필요가 없고 데이터 가공 클래스에서 수정해주면 되니 유지보수면에서도 장점이 있다.

- 서버는 어느 한 도메인에 맞추지 않고 어떤 요청에도 유연하게 대응할 수 있는 구조를 갖추어야한다.
- Class : 접근자 프로퍼티(get, set)를 사용하면 바깥 코드에서 일반 프로퍼티처럼 사용할 수 있다.

## (미완) 인스턴스와 메모리

https://velog.io/@younoah/JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EA%B0%9D%EC%B2%B4-%EC%B4%9D%EC%A0%95%EB%A6%AC

## 가비지 컬렉션이란?

## v8 메모리 구조

- V8 프로세스에 할당된 일정량의 메모리는 레시던트 세트라는 구조를 갖는다.
- 이 구조 안에는 스택, 힙 메모리가 있다.
- 가비지 컬렉션은 힙 메모리 중에서도 new space와 old space서만 실행된다.
- new space 영역에서는 새로 만들어진 객체를 저장하고, 짧은 생명 주기를 갖는다. 이 영역의 크기는 old space에 비해 작고, 마이너 가비지컬렉션이 관리한다.
- old space 영역에서는 ... 메이저 가바지컬렉션이 관리한다.

- V8 엔진은 자바스크립트를 해석하고 컴파일하여 기계어로 변환한다.
- 자바스크립트가 단일 스레드이기 때문에 V8은 자바스크립트 컨텍스트 당 한 개의 프로세스를 사용한다.

## v8 메모리 사용

- int, string 같은 원시 타입은 스택에 바로 저장된다.
- 반면 Function 과 같은 객체 타입은 힙에서 생성이 되고, 스택에서 정보가 필요할 때 스택 포인터를 사용해 힙 메모리를 가리킨다.
- 함수가 종료될 때 원시타입 값들은 스택에서 제거된다.
- 반면 객체 타입은 어떤 포인터도 갖지 않고 힙 메모리에 남는다.

- 따라서, 메모리힙은 자동으로 관리되지 않아 시간이 지날수록 사용되는 메모리양이 증가한다.
- = v8 엔진에서 스택은 자동으로 관리가 되어(운영체제) 함수가 호출되면 스택 구조체에서 사라진다.

## v8 엔진은 가비지컬렉션을 이용해 메모리 관리

- 가비지컬렉션은 스택으로부터 더 이상 참조하지 않는 객체를 비워서 새로운 객체를 생성하기 위한 공간을 만들어 준다.
- v8 엔진의 가비지컬렉션은 세부적으로 마이너 가비지컬렉션과 메이저 가바지컬렉션으로 동작한다.

1. 마이너 가비지 컬렉션

   - 힙 메모리 영역 중 new space를 작고 깨끗하게 유지시키는 가비지 컬렉션이다.
   - 객체가 생성되면 new space에 할당된다. (1~8mb)
   - 첸니 알고리즘을 활용한다.
   - 새 객체에 대한 공간을 마련하려고 할 때마다 할당 포인터라는 것이 증가하는데 이 할당 포인터가 new space의 마지막에 도달하면 마이너 가비지 컬렉션이 발생한다.
     - 과정
       - from-space에서 메모리를 할당하려고 할 때 공간이 없는 경우 첫번째 마이너 가비지컬렉션이 발생한다.
       - 마이너가비지컬렉션은 스택 포인터를 활용해 from-space에 참조 중인 객체가 있는 경우 to-space로 옮겨준다.
       - 이 과정에서 from-space에 남은 객체들은 가비지이므로 마이너 가비지 컬렉션이 from-space를 비운다.
       - 새 객체는 to-space에 할당된다
       - 할당이 끝나면 to-spcae와 from-space의 역할이 바뀐다
       - 시간이 지나서 from-spcae에 새 객체를 할당시키려할 때 공간이 없는 경우 두번째 마이너 가비지컬렉션이 발생한다.
       - 스택 포인터를 활용해 from-spcae에 참조 중인 객체가 있는 경우 이번엔 Old-space로 이동한다.
       - 이 과정에서 from-space에 남은 객체들은 가비지이므로 마이너 가비지 컬렉션이 from-space를 비운다.

2. 메이저 가비지 컬렉션

   - 마이너 가비지 컬렉션이 2번 발생할 동안 살아남은 객체들이 저장된다.
   - old-space 의 메모리가 충분하지 않다고 판단될 때 발생한다.
   - Mark-Sweep-Compact 알고리즘과 Tri-color 알고리즘을 사용한다.
   - 마킹, 스위핑, 압축 단계의 과정을 갖는다.
     - 1. 마킹 : 어떤 객체들이 가비지 컬렉션 대상인지 알아내는 단계이다.
       - 전역 객체를 담고 있는 세트부터 시작해 객체들을 `깊이 우선 탐색`으로 순회해 세가지 색상으로 마킹한다.
         - 흰색 : 아직 탐색 못한 상태
         - 회색 : 탐색은 했는데 객체가 다른 객체를 참조하고 있는지 확인은 못한 상태
         - 검정 : 탐색도 했고 객체가 다른 객체를 참조하고 있는지 확인된 상태
       - 과정
         - 모든 객체는 흰색으로 마킹된다.
         - 루트 객체를 회색으로 마킹 후 마킹 작업 목록에 push_front 시킨다.
         - 마킹 작업 목록에 pop_front하여 객체를 꺼내 검정으로 칠한다.
         - 꺼낸 객체가 참조하는 객체들은 회색으로 다시 칠해 마킹 작업 목록에 push_front 시킨다.
         - 이걸 반복해 마킹 작업 목록이 비게되면 최종적으로 검정과 흰색만 남는다.
   - 2. 스위핑

        - 흰색으로 마킹된 객체들의 메모리 주소를 메모리 사용이 가능한 주소로 등록시켜 새로운 객체 등록이 가능하도록 한다.

   - 3. 압축
        - 메모리 단편화가 심한 페이지들을 재배치해 추가 메모리를 확보한다.

- 스택 : 나중에 들어간 것이 처음 나오는 구조
- 큐 : 처음 들어간 것이 처음 나오는 구조
- 덱 : 스택과 큐를 합쳐놓은 구조 (https://visualgo.net/en/list?slide=3)

https://teraphonia.tistory.com/800
https://ui.toast.com/weekly-pick/ko_20200228
https://fe-developers.kakaoent.com/2022/220519-garbage-collection/

## ✨ 이를 관리하기 위해 수행한 점은?

## ✨ JavaScript에서 메모리 누수의 원인 및 해결 방법?

1. 전역 변수 사용하지 않기

   - 가비지콜렉터 입장에서 전역객체는 항상 존재해야하니, 전역 객체 하위 자식들 또한 모두 가비지 대상에서 제외한다.
   - 전역 변수에 대량의 정보를 할당시키지 않아야하고 할당시켜도 작업이 끝나면 null 처리해주는 작업이 필요하다.

2. 돔 요소를 제거할때 해당 요소의 변수는 삭제시키는 함수 내부에 위치시켜 함수가 콜스택에서 사라질 때 해당 요소를 참조하는 값도 같이 제거

   - 제거할 요소의 변수를 삭제시키는 핸들러 외부에 위치시키면 화면상에서 요소는 사라지지만
     해당 요소를 참조하고 있는 값은 해제가 되지 않아 메모리 누수의 원인이 된다.

3. 타이머는 작업이 끝나면 해제하기
   - 타이머에 사용된 콜백 함수들은 함수가 종료되어도 사용된 변수들을 계속 참조하기 때문에
     clearInterval, cleartimeout과 같이 타이머를 해지하는 작업을 해줘야 한다.

https://ui.toast.com/posts/ko_20210611
https://jeongjihun.github.io/posts/Causes-of-Memory-Leaks-in-JavaScript-and-How-to-Avoid-Them
https://yceffort.kr/2020/07/memory-leaks-in-javascript

## ✨ (더) 웹 성능 개선 방법

1. 사용하지 않는 css 제거한다.

- css, js와 같은 리소스는 브라우저의 렌더링을 지연시킬 수 있는 요소이다.
- 실무에서는 배포할 때 사용된 css만 추출해주는 tailwindcss css 프레임워크를 적용 준비 중에 있다.

2. html 마크업 작업을 할 때 태그의 자식 요소들의 깊이가 깊어지지 않도록 코드를 짠다.

- 브라우저가 렌더링을 할 때 생성하는 DOM 트리는 크기가 작고 깊이가 얕을 수록 계산이 빠르다.
- 실무에서는 불필요한 wrapper 태그들은 제거하고 자식 컴포넌트를 작업해야할 때는 합성 함수 방식으로 코드를 짜 얕은 깊이를 유지한다.

3. 애니메이션 표현은 js api < css를 사용한다.

- css를 활용하면 브라우저의 메인 스레드가 아닌 컴포짓 스레드를 활용할 수 있다.
- 단순한 위치 이동을 시키는 애니메이션에서 transform 속성을 활용하면 브라우저에서 리플로우, 리페인트를 발생하지 않아 렌더링 속도를 향상할 수 있다.

4. 모듈 번들러를 사용해 브라우저 렌더링이 될 때 받아오는 리소스 요청을 줄인다.

5. 변동이 없는 정적 리소스의 경우 캐싱을 시켜 이후 동일한 url 리소스 요청에 대한 응답 속도를 빠르게 처리한다.

6. gzip을 사용해 텍스트 기반의 리소스를 압축시켜 브라우저 리소스에 대한 응답 크기를 가볍게 유지한다.

- 세부 gzip 내용 추가

## ✨ 웹 접근성 고려한 개발 방법

1. html에서의 접근성

- 문서에서 사용할 언어를 lang 속성을 통해 지정한다.

  - 올바른 언어를 문서에 정의하면 스크린리더기와 같은 보조 기술이 올바른 음성을 인식하는데 도움이 된다.

- 이미지 컨텐츠가 단순 그래픽용도가 아닌 컨텐츠 내용을 담고 있다면 alt 속성을 사용해 설명글을 기재해준다
- \*버튼 용도로 사용하는 요소는 div가 아닌 button 태그를 사용한다.
  - 버튼 요소 자체가 브라우저에서 제공해 주는 포커스 기능을 제공해줘서 탭 키보드로 버튼에 접근할 때 스페이스바/엔터바를 통해 클릭 액션이 가능하다
  - 시각 장애 사용자의 경우 음성 스크린 리더기에 의존하는데 버튼을 버튼 태그로 짜면 음성으로 전달될 때 해당 컨텐츠가 버튼이라고 명확하게 사용자에게 전달한다.
- \*h 태그를 사용해 문서의 제목들에 우선순위를 구분 짓고 문서의 섹션별 관계를 나타내줄 수 있게 마크업하는 것도 사용자들이 보조 기술을 이용해 컨텐츠를 탐색하는데 도움이 된다. (shift+h)
- \*한 페이지의 헤더, 컨텐츠, 푸터가 존재할 때 각각의 영역에 해당하는 랜드마크 태그는 1개씩만 지정해 사용자가 Alt + Shift + N 단축키만으로 랜드마크 영역 이동이 가능하도록 제공한다.
- \*라벨텍스트가 붙은 인풋의 경우 인풋 라벨에 해당하는 요소는 라벨 태그를 사용해 사용자가 라벨을 클릭해도 인풋에 포커스가 가도록 접근성을 높인다.

2. js에서의 접근성

- 모달 팝업 내부에 인풋 요소가 있는 경우 팝업이 열린 순간 사용자가 바로 인풋에 입력값을 넣을 수 있도록 인풋에 포커싱시킨다
- 인풋박스에 들어갈 값의 범위를 사용자가 알 수 있도록 유효성 검사 코드를 추가한다

3. css에서의 접근성

- 글자 크기를 화면 사이즈를 고려해 설정한다. 일반 모니터 기준에서의 평균 본문 크기는 16~18 픽셀이고, 스마트폰 사이즈의 평균 본문 크기는 18~20 픽셀이 적당하다.
- 폰트 패밀리마다 최적화된 최소 사이트가 있는 걸 고려해 적용한다.
- 계산은 픽셀로 하되 기재는 rem 단위로 추가해 브라우저 내의 글꼴 사이즈에 따라 글자 비율이 따라갈 수 있도록 의도한다.
- 사용자의 액션에 컨텐츠가 원만한 상호작용이 될 수 있도록 요소의 :호버, :포커스, :액션 케이스에 대한 css 작성이 고려되어야 한다.

- vh & vw : 브라우저의 높이/너비 값의 100분의 1 단위로 지정 (700px 높이면 1vh 7px)
- vmin : 브라우저의 높이나 너비 값 중에 더 작은 걸 기준으로 100분의 1 단위로 지정
- vmax : 브라우저의 높이나 너비 값 중에 더 큰 걸 기준으로 100분의 1 단위로 지정
  ex. 1000px 500px 브라우저 크기에 width:50vmin, height:50vmin 박스를 그린다면 실제 계산되는 너비값은 브라우저의 높이나 너비 중에 높이 값이 더 작으므로 500px을 기준으로 50vmin이나 500\*0.5 = 250픽셀이 지정

> 웹 접근성 : 웹 콘텐츠를 모든 사용자가 동등하게 접근할 수 있도록 제작하는 방법
> 웹 표준 :

https://medium.com/@matuzo/writing-css-with-accessibility-in-mind-8514a0007939

## 리액트 메모리 누수

## 포인터

## ✨ 자바스크립트 동작 방식?

## ✨ 뷰포트부터 반응형 웹

https://velog.io/@bityoungjae/%EB%B7%B0%ED%8F%AC%ED%8A%B8%EB%B6%80%ED%84%B0-%EB%B0%98%EC%9D%91%ED%98%95-%EC%9B%B9%EA%B9%8C%EC%A7%80-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC

## ✨ 트러블슈팅 경험

## 비동기 구문의 실행 방식과 순서에 대해서 이야기

## CORS

## SSR CSR

## 웹어셈블리

[cs지식정리](https://velog.io/@joy37/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-CS-%EC%A7%80%EC%8B%9D-%EC%A0%95%EB%A6%AC#3-%EB%8F%99%EA%B8%B0%EC%99%80-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90)
