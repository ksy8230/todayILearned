## ✨ 타입 시스템에 대해서 알고 있는지? 타입스크립트를 써봤는지?

타입스크립트는 자바스크립트의 상위호환언어다.

문자열, 숫자, 불린, 배열, 튜플,이넘, 애니, 언노운, 널, 언디파인드, 보이드 등

### 자바스크립트와 타입스크립트의 차이점?

타입의 차이가 있다.

타입스크립트는 코드에 타입을 부여하기 때문에 타입의 안정성을 보장하면서 개발이 가능하다.
IDE(통합개발환경)에서 ctrl+click만으로 해당 코드의 타입을 찾아내 사용법 유추가 가능하다.

자바스크립트는 타입 시스템이 없는 동적 프로그래밍 언어다. 변수에 타입을 지정하지 않아도 문자, 숫자, 불리언 등 다양한 타입을 가질 수 있다. 유연하게 개발할 수 있는 환경을 제공하지만 런타임에서 에러가 발생할 수 있다.

### 타입스크립트의 장점과 단점?

(장점)

1. 런타임이 아닌, 컴파일 단계에서 오류를 잡을 수 있다.
2. 함수의 인자 개수가 잘못되거나 타입이 다른 인자를 전달 시 에러를 표시하기 때문에 개발자 입장에서 높은 생산성을 가져갈 수 있다.
3. 타입 추론 기능이 있어 모든 코드에 타이핑을 할 필요가 없다.
4. 외부 라이브러리를 사용해 라이브러리에서 지원하는 특정 함수를 사용해야할 때 때 타입 파일을 통해 사용법 유추가 가능하다.

(단점)

1. 타입스크립트를 설정하기 위한 초기 세팅 과정이 필요하다.
2. 타입핑이 추가되기 때문에 코드 길이가 길어진다.

## 이벤트 핸들러란?

특정 요소에서 발생한 이벤트를 처리하기 위해 사용하는 함수이다.
지정된 타입의 이벤트가 발생하면 브라우저는 그 타입과 연결된 이벤트 핸들러를 실행한다.
onclick, onkeydown, onmousedonwn, 등등

## 이벤트 위임?

## setState로 상태 변화를 해야 하는 이유?

## ✨ (미완) 방통대 관련 cs 준비

[dfs 깊이우선탐색 알고리즘](https://gmlwjd9405.github.io/2018/08/14/algorithm-dfs.html)
[페이징/내부 단편화](https://jhnyang.tistory.com/290)

## ✨ 알고리즘 관련 -> 개선 방안 흐름으로 풀기

## 컴파일러는 뭐고 인터프리터는 뭔가요?

`자바스크립트는 인터프리터 언어`이다. 개발자도구 콘솔에 스크립트를 작성하면 바로 실행되는 걸 확인할 수 있기 때문이다. 하지만 대부분의 브라우저는 엔진 내부에서 코드의 최적화를 위해 컴파일 과정을 거친다.

- 자바스크립트 파서가 동작하는 방식
  - 자바스크립트 파서는 특정 코드가 바로 실행될지, 지연 실행될지를 결정한다. 파서는 함수의 호출 선언들을 분석해서 바로 실행되어야하는 함수가 있다면 괄호로 묶는 방식으로 코드를 수정해 해당 함수 먼저 구문 분석을 수행한다.

> `컴파일러`란 인간에게 가까운 `고급 언어를 기계어로 변환시켜주는 프로그램`  
> `인터프리터`란 고급 언어를 `한 줄 단위로 번역과 동시에 실행시켜주는 프로그램`
> 어떤 프로그래밍 언어를 사용하든 소스 코드를 가져와서 컴퓨터가 실제로 무언가를 하도록 만들 수 있는 소프트웨어가 항상 필요하다. 이 소프트웨어가 컴파일러와 인터프리터이다.

> https://blog.sessionstack.com/how-javascript-works-parsing-abstract-syntax-trees-asts-5-tips-on-how-to-minimize-parse-time-abfcf7e8a0c8

## 자바스크립트 동작 방식 (네트워크 계층)

<브라우저와 서버간의 상호작용 방식>

브라우저 주소창에 URL을 입력하면 브라우저는 로컬과 어플리케이션 캐시를 확인한다.
캐시가 없거나 사용할 수 없는 경우 브라우저는 URL에서 도메인 이름은 가져와 DNS를 통해 IP 주소로 요청한다.  
브라우저는 IP주소에 해당하는 웹 페이지를 요청하기 위해 HTTP 패킷을 생성한다.
이 패킷은 TCP/IP 계층으로 이동되고, 여기서 통신할 컴퓨터끼리의 정보 교환을 위한 준비가 완료된다.
그 다음 패킷은 원격 서버로 패킷을 보내는 방법을 파악하는 IP 계층으로 전달된다.
패킷이 물리 계층으로 보내지면, 수신하는 원격 서버로 데이터를 전송된다.

> DNS : 사람이 읽을 수 있는 도메인 이름을 기계가 읽을 수 있는 IP주소로 변환하는 시스템
> HTTP 패킷 : 통신망을 통해 전송이 쉽도록 잘라낸 데이터 전송 단위
> (P) 프로토콜 : 통신 규약
> (IP) : 인터넷 통신 규약
> TCP : 연결 지향 프로토콜
> TCP/IP (Transmisstion) : IP를 이용해 목적지에 도달하고, TCP를 활용해 연결을 맺고 신뢰성을 유지하겠다는 통신규약

      - 통신할 컴퓨터끼리 "보냈다" "도착했다"라는 확인 메세지를 보내면서 데이터를 주고 받아 통신의 신뢰성을 유지한다

https://resilient-923.tistory.com/277

## ✨ 자바스크립트 동작 방식 (브라우저)?

자바스크립트는 브라우저와 같은 자바스크립트 런타임 환경에서 동작한다. 이런 자바스크립트 엔진은 크게 콜스택과 힙메모리로 이루어져있다. 힙메모리는 함수,변수와 같은 값을 임시 저장하는 곳이고, 콜스택은 코드의 실행 순서를 기억시켜주는 곳이다.
콜스택에서 코드가 실행될 때 콜백함수들은 브라우저 웹 API에게 위임된다.
브라우저 웹 API는 콜백함수 종류에 따라 함수들을 태스크큐로 보낸다.
Promise와 같은 콜백함수는 마이크로태스트큐에 보내지고,
돔 이벤트 콜백함수나, setTimout과 같은 콜백 함수는 매크로태스크큐에 보내진다.
requestAnimationFrame와 같은 콜백 함수는 렌더큐로 보내진다.
마이크로태스크큐와 렌더큐는 매크로태스크큐보다 우선 순위가 높기 때문에 마이크로태스크큐와 렌더큐 내부의 작업이 모두 실행된 다음에 매크로태스크큐에서 작업이 하나씩 실행된다.
순서로는, 마이크로태스크큐가 모두 실행되고 렌더링 시점이 오면 렌더큐가 실행되고, 그 다음에 매크로태스크큐가 실행된다.
그리고 이와 같은 태스크 큐 관리를 이벤트 루프가 처리한다.
이벤트 루프가 태스크큐에 있던 함수들을 콜스택으로 보내고, 콜스택이 모두 비워지면 프로그램이 종료된다.

> 렌더큐:
> 브라우저웹API: 비동기이벤트처리기로, 브라우저 안에 C++로 구현된 스레드이다.
> 이벤트루프: 태스크들의 관리자이자로, 자바스크립트 엔진 내부에 존재하는 루프다.

## 정확히 어떤 포트폴리오인지 세부 설명 준비 👇

## ✨ 심층 URL 보안 모니터링 웹 사이트 2차 사업은 어떤 것인가?

대량의 웹사이트들을 패턴 점검시켜 악성,의심,정상으로 나눠 모니터링할 수 있는 제품을 만드는 사업이었다.
자사가 갖고 있는 데이터를 가지고 AI로 학습시켜 나온 패턴이랑 넷스파이더라는 패턴 기반의 분석기를 이용해 점검한다.
여기에 고객사가 갖고 있는 패턴을 추가할 수 있는 인터페이스를 제공하는 방식이었다.

<!-- 배포 프로세스 설명도 가능한가? -->
<!-- 쿠버네티스를 이용해 웹사이트들을 분석시킬 분석기들을 관리하고 웹 어플리케이션과 api 서버를 배포한다. -->

## ✨ 어떤 프로젝트를 진행 했고, 거기서 어떤 역할을 했는지. 또, 주니어로서 과제를 해결하는데 어떤 어려움이 있었는지?

진행한 대부분의 프로젝트들은 보안 관제 인력이, 위험으로 판단되는 URL 모니터링할 수 있는 대시보드형 웹 사이트를 개발하는 일이었다.
저는 여기서 분석 결과로 나온 수치를 사용자가 이해할 수 있는 웹 UI로 표현하는 업무가 중요했다.

해당 업무를 진행하기 위해 가시성이 높은 UI 표현법인 그래프를 활용해 통계 대시보드를 만들어보았고,
그래프 작업은 canvas 기반으로 만들어진 그래프 라이브러리를 사용해 구현하였다.
canvas 기반은 차트에 표현할 오브젝트가 아무리 많아도 결국 렌더링되는건 canvas 태그 하나이기 때문에
드래그 앤 드랍 형태로 재배치되는 반응형 그래프 UI에서 렌더링 성능 저하를 대응하였다.

그리고 드래그 액션으로 그래프 사이즈가 조절되는 기능도 있었는데,
그래프의 사이즈를 조정할 때 선명도가 어느 지점에서 깨지는 현상이 있었고,
이런 현상은 해당 디스플레이마다 css 1픽셀을 그리는데 사용되는 실제 픽셀수를 계산해주는 `window.devicePixelRatio` 값을 배수로 활용해 적용하여 선명도를 개선하였다.

<!-- 렌더링 최적화 측면에서 화면에 표현할 오브젝트가 단 하나로 표현되는 canvas 기반이고,  만들어진 -->

분석 결과 데이터가 대량인 경우,

## ✨ 팀 내부 연구 과제용으로 활용할 플랫폼형 프로젝트

해당 사업의 목표는 아마존에서 사용하는 서비스들의 금액 사용량을 모니터링하고 같은 그룹 권한에 있는 사용자들의 ip를 조회해 로그를 확인할 수 있고 의심스러운 행위를 하는 ip를 차단하는 기능을 제공 제품을 만드는게 목표였는데
컨텐츠 자체가 다 정해지지 않은 초안 단계에서 중단된 상태이다.
컨텐츠가 정해지면 활용할 수 있도록 ui들만 미리 만들어놓은 프로젝트라고 이해하시면 될 것 같습니다.

##

## ✨ 데이터 가공 처리가 필요한 이유?

api를 호출했을 때 해당 ui에 꼭 필요한 데이터만 줬으면 좋겠지만 프로젝트가 복잡하고 커져서 서버가 도메인 단위로 코드를 관리해야하는 경우 데이터가 브라우저에 렌더링되기 위한 가공이 필요하다.
예를 들어 프론트는 응답 받은 데이터리스트가 없는 경우의 조건식을 추가해 UI를 보여줘야하거나
응답받은 리스트들 중 악성 태그가 붙은 리스트만 보여줘야하는 경우 필터링을 시키는 작업과 같은 가공이 필요하다.

## ✨ 데이터 가공 처리 어떻게 했나?

이런 조건식을 추가하고 필터링 코드를 붙이는 작업 자체는 어렵지않지만
매 페이지마다 미묘하게 필요한 데이터들이 달라서 그때마다 가공처리 코드를 붙이는게 지저분하다 판단했다.

https://velog.io/@jjunyjjuny/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EA%B0%80%EA%B3%B5%ED%95%98%EB%9D%BC

### Class Instance로 변환

Class의 Instance를 활용해 가공 처리 작업을 개선해보았다.
Class를 활용하게 되면 데이터를 가공하는 책임을 해당 클래스에게 위임을 할 수 있어서 가공처리와 관련된 코드의 응집성이 높아진다.

예를 들어서 url 리스트에 관련된 가공 데이터가 필요한 경우 UrlData라는 클래스를 만들어 내부에 데이터리스트가 없는 경우 (getter 메서드를 활용해) isEmpty라는 프로퍼티를 만들어둔다. 그리고 외부에서 필요한 가공처리가 적용된 속성을 사용할 수 있도록 코드를 개선해본 경험이 있다.

1. 이렇게 되면 가공처리 코드가 여기저기에 산재되어있는게 아니라 한군데에 묶어서 관리할 수 있고,
2. UI를 렌더링하는 코드에선 가공처리로직이 빠지면서 view 역할에 집중할 수 있게 된다.
3. 서버의 API 응답 스키마가 확정되지 않은 상태라도 클라이언트에서 사용할 데이터의 인터페이스를 우선 정의해둘 수 있어서 API가 미완성일지라도 레이아웃 작업을 먼저 진행할 수 있다.
   - 4. 나중에 API에서 내려준 데이터가 달라져도 view단은 건드릴 필요가 없고 데이터 가공 클래스에서 수정해주면 되니 유지보수면에서도 장점이 있다.

- 서버는 어느 한 도메인에 맞추지 않고 어떤 요청에도 유연하게 대응할 수 있는 구조를 갖추어야한다.
- Class : 접근자 프로퍼티(get, set)를 사용하면 바깥 코드에서 일반 프로퍼티처럼 사용할 수 있다.

## (미완) 인스턴스와 메모리

https://velog.io/@younoah/JS-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EA%B0%9D%EC%B2%B4-%EC%B4%9D%EC%A0%95%EB%A6%AC

## 가비지 컬렉션이란?

## v8 메모리 구조

- V8 프로세스에 할당된 일정량의 메모리는 레시던트 세트라는 구조를 갖는다.
- 이 구조 안에는 스택, 힙 메모리가 있다.
- 가비지 컬렉션은 힙 메모리 중에서도 new space와 old space서만 실행된다.
- new space 영역에서는 새로 만들어진 객체를 저장하고, 짧은 생명 주기를 갖는다. 이 영역의 크기는 old space에 비해 작고, 마이너 가비지컬렉션이 관리한다.
- old space 영역에서는 ... 메이저 가바지컬렉션이 관리한다.

- V8 엔진은 자바스크립트를 해석하고 컴파일하여 기계어로 변환한다.
- 자바스크립트가 단일 스레드이기 때문에 V8은 자바스크립트 컨텍스트 당 한 개의 프로세스를 사용한다.

## v8 메모리 사용

- int, string 같은 원시 타입은 스택에 바로 저장된다.
- 반면 Function 과 같은 객체 타입은 힙에서 생성이 되고, 스택에서 정보가 필요할 때 스택 포인터를 사용해 힙 메모리를 가리킨다.
- 함수가 종료될 때 원시타입 값들은 스택에서 제거된다.
- 반면 객체 타입은 어떤 포인터도 갖지 않고 힙 메모리에 남는다.

- 따라서, 메모리힙은 자동으로 관리되지 않아 시간이 지날수록 사용되는 메모리양이 증가한다.
- = v8 엔진에서 스택은 자동으로 관리가 되어(운영체제) 함수가 호출되면 스택 구조체에서 사라진다.

## v8 엔진은 가비지컬렉션을 이용해 메모리 관리

- 가비지컬렉션은 스택으로부터 더 이상 참조하지 않는 객체를 비워서 새로운 객체를 생성하기 위한 공간을 만들어 준다.
- v8 엔진의 가비지컬렉션은 세부적으로 마이너 가비지컬렉션과 메이저 가바지컬렉션으로 동작한다.

1. 마이너 가비지 컬렉션

   - 힙 메모리 영역 중 new space를 작고 깨끗하게 유지시키는 가비지 컬렉션이다.
   - 객체가 생성되면 new space에 할당된다. (1~8mb)
   - 첸니 알고리즘을 활용한다.
   - 새 객체에 대한 공간을 마련하려고 할 때마다 할당 포인터라는 것이 증가하는데 이 할당 포인터가 new space의 마지막에 도달하면 마이너 가비지 컬렉션이 발생한다.
     - 과정
       - from-space에서 메모리를 할당하려고 할 때 공간이 없는 경우 첫번째 마이너 가비지컬렉션이 발생한다.
       - 마이너가비지컬렉션은 스택 포인터를 활용해 from-space에 참조 중인 객체가 있는 경우 to-space로 옮겨준다.
       - 이 과정에서 from-space에 남은 객체들은 가비지이므로 마이너 가비지 컬렉션이 from-space를 비운다.
       - 새 객체는 to-space에 할당된다
       - 할당이 끝나면 to-spcae와 from-space의 역할이 바뀐다
       - 시간이 지나서 from-spcae에 새 객체를 할당시키려할 때 공간이 없는 경우 두번째 마이너 가비지컬렉션이 발생한다.
       - 스택 포인터를 활용해 from-spcae에 참조 중인 객체가 있는 경우 이번엔 Old-space로 이동한다.
       - 이 과정에서 from-space에 남은 객체들은 가비지이므로 마이너 가비지 컬렉션이 from-space를 비운다.

2. 메이저 가비지 컬렉션

   - 마이너 가비지 컬렉션이 2번 발생할 동안 살아남은 객체들이 저장된다.
   - old-space 의 메모리가 충분하지 않다고 판단될 때 발생한다.
   - Mark-Sweep-Compact 알고리즘과 Tri-color 알고리즘을 사용한다.
   - 마킹, 스위핑, 압축 단계의 과정을 갖는다.
     - 1. 마킹 : 어떤 객체들이 가비지 컬렉션 대상인지 알아내는 단계이다.
       - 전역 객체를 담고 있는 세트부터 시작해 객체들을 `깊이 우선 탐색`으로 순회해 세가지 색상으로 마킹한다.
         - 흰색 : 아직 탐색 못한 상태
         - 회색 : 탐색은 했는데 객체가 다른 객체를 참조하고 있는지 확인은 못한 상태
         - 검정 : 탐색도 했고 객체가 다른 객체를 참조하고 있는지 확인된 상태
       - 과정
         - 모든 객체는 흰색으로 마킹된다.
         - 루트 객체를 회색으로 마킹 후 마킹 작업 목록에 push_front 시킨다.
         - 마킹 작업 목록에 pop_front하여 객체를 꺼내 검정으로 칠한다.
         - 꺼낸 객체가 참조하는 객체들은 회색으로 다시 칠해 마킹 작업 목록에 push_front 시킨다.
         - 이걸 반복해 마킹 작업 목록이 비게되면 최종적으로 검정과 흰색만 남는다.
   - 2. 스위핑

        - 흰색으로 마킹된 객체들의 메모리 주소를 메모리 사용이 가능한 주소로 등록시켜 새로운 객체 등록이 가능하도록 한다.

   - 3. 압축
        - 메모리 단편화가 심한 페이지들을 재배치해 추가 메모리를 확보한다.

- 스택 : 나중에 들어간 것이 처음 나오는 구조
- 큐 : 처음 들어간 것이 처음 나오는 구조
- 덱 : 스택과 큐를 합쳐놓은 구조 (https://visualgo.net/en/list?slide=3)

https://teraphonia.tistory.com/800
https://ui.toast.com/weekly-pick/ko_20200228
https://fe-developers.kakaoent.com/2022/220519-garbage-collection/

## ✨ 이를 관리하기 위해 수행한 점은?

## ✨ JavaScript에서 메모리 누수의 원인 및 해결 방법?

1. 전역 변수 사용하지 않기

   - 가비지콜렉터 입장에서 전역객체는 항상 존재해야하니, 전역 객체 하위 자식들 또한 모두 가비지 대상에서 제외한다.
   - 전역 변수에 대량의 정보를 할당시키지 않아야하고 할당시켜도 작업이 끝나면 null 처리해주는 작업이 필요하다.

2. 돔 요소를 제거할때 해당 요소의 변수는 삭제시키는 함수 내부에 위치시켜 함수가 콜스택에서 사라질 때 해당 요소를 참조하는 값도 같이 제거

   - 제거할 요소의 변수를 삭제시키는 핸들러 외부에 위치시키면 화면상에서 요소는 사라지지만
     해당 요소를 참조하고 있는 값은 해제가 되지 않아 메모리 누수의 원인이 된다.

3. 타이머는 작업이 끝나면 해제하기
   - 타이머에 사용된 콜백 함수들은 함수가 종료되어도 사용된 변수들을 계속 참조하기 때문에
     clearInterval, cleartimeout과 같이 타이머를 해지하는 작업을 해줘야 한다.

https://ui.toast.com/posts/ko_20210611
https://jeongjihun.github.io/posts/Causes-of-Memory-Leaks-in-JavaScript-and-How-to-Avoid-Them
https://yceffort.kr/2020/07/memory-leaks-in-javascript

## ✨ (더) 웹 성능 최적화 방법

1. 사용하지 않는 css 제거한다.

- css, js와 같은 리소스는 브라우저의 렌더링을 지연시킬 수 있는 요소이다.
- 실무에서는 배포할 때 사용된 css만 추출해주는 tailwindcss css 프레임워크를 적용 준비 중에 있다.

2. html 마크업 작업을 할 때 태그의 자식 요소들의 깊이가 깊어지지 않도록 코드를 짠다.

- 브라우저가 렌더링을 할 때 생성하는 DOM 트리는 크기가 작고 깊이가 얕을 수록 계산이 빠르다.
- 실무에서는 불필요한 wrapper 태그들은 제거하고 자식 컴포넌트를 작업해야할 때는 합성 함수 방식으로 코드를 짜 얕은 깊이를 유지한다.

3. 애니메이션 표현은 js api < css를 사용한다.

- css를 활용하면 브라우저의 메인 스레드가 아닌 컴포짓 스레드를 활용할 수 있다.
- 단순한 위치 이동을 시키는 애니메이션에서 transform 속성을 활용하면 브라우저에서 리플로우, 리페인트를 발생하지 않아 렌더링 속도를 향상할 수 있다.

4. 모듈 번들러를 사용해 브라우저 렌더링이 될 때 받아오는 리소스 요청을 줄인다.

5. 변동이 없는 정적 리소스의 경우 캐싱을 시켜 이후 동일한 url 리소스 요청에 대한 응답 속도를 빠르게 처리한다.

6. gzip을 사용해 텍스트 기반의 리소스를 압축시켜 브라우저 리소스에 대한 응답 크기를 가볍게 유지한다.

- 세부 gzip 내용 추가

https://velog.io/@hsecode/%EC%B5%9C%EC%A0%81%ED%99%94-%EC%9B%B9-%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94-%EB%B0%A9%EB%B2%95-5%EB%B6%84-%EC%99%84%EC%84%B1

## ✨ 웹 접근성 고려한 개발 방법

1. html에서의 접근성

- 문서에서 사용할 언어를 lang 속성을 통해 지정한다.

  - 올바른 언어를 문서에 정의하면 스크린리더기와 같은 보조 기술이 올바른 음성을 인식하는데 도움이 된다.

- 이미지 컨텐츠가 단순 그래픽용도가 아닌 컨텐츠 내용을 담고 있다면 alt 속성을 사용해 설명글을 기재해준다
- \*버튼 용도로 사용하는 요소는 div가 아닌 button 태그를 사용한다.
  - 버튼 요소 자체가 브라우저에서 제공해 주는 포커스 기능을 제공해줘서 탭 키보드로 버튼에 접근할 때 스페이스바/엔터바를 통해 클릭 액션이 가능하다
  - 시각 장애 사용자의 경우 음성 스크린 리더기에 의존하는데 버튼을 버튼 태그로 짜면 음성으로 전달될 때 해당 컨텐츠가 버튼이라고 명확하게 사용자에게 전달한다.
- \*h 태그를 사용해 문서의 제목들에 우선순위를 구분 짓고 문서의 섹션별 관계를 나타내줄 수 있게 마크업하는 것도 사용자들이 보조 기술을 이용해 컨텐츠를 탐색하는데 도움이 된다. (shift+h)
- \*한 페이지의 헤더, 컨텐츠, 푸터가 존재할 때 각각의 영역에 해당하는 랜드마크 태그는 1개씩만 지정해 사용자가 Alt + Shift + N 단축키만으로 랜드마크 영역 이동이 가능하도록 제공한다.
- \*라벨텍스트가 붙은 인풋의 경우 인풋 라벨에 해당하는 요소는 라벨 태그를 사용해 사용자가 라벨을 클릭해도 인풋에 포커스가 가도록 접근성을 높인다.

2. js에서의 접근성

- 모달 팝업 내부에 인풋 요소가 있는 경우 팝업이 열린 순간 사용자가 바로 인풋에 입력값을 넣을 수 있도록 인풋에 포커싱시킨다
- 인풋박스에 들어갈 값의 범위를 사용자가 알 수 있도록 유효성 검사 코드를 추가한다

3. css에서의 접근성

- 글자 크기를 화면 사이즈를 고려해 설정한다. 일반 모니터 기준에서의 평균 본문 크기는 16~18 픽셀이고, 스마트폰 사이즈의 평균 본문 크기는 18~20 픽셀이 적당하다.
- 폰트 패밀리마다 최적화된 최소 사이트가 있는 걸 고려해 적용한다.
- 계산은 픽셀로 하되 기재는 rem 단위로 추가해 브라우저 내의 글꼴 사이즈에 따라 글자 비율이 따라갈 수 있도록 의도한다.
- 사용자의 액션에 컨텐츠가 원만한 상호작용이 될 수 있도록 요소의 :호버, :포커스, :액션 케이스에 대한 css 작성이 고려되어야 한다.

- vh & vw : 브라우저의 높이/너비 값의 100분의 1 단위로 지정 (700px 높이면 1vh 7px)
- vmin : 브라우저의 높이나 너비 값 중에 더 작은 걸 기준으로 100분의 1 단위로 지정
- vmax : 브라우저의 높이나 너비 값 중에 더 큰 걸 기준으로 100분의 1 단위로 지정
  ex. 1000px 500px 브라우저 크기에 width:50vmin, height:50vmin 박스를 그린다면 실제 계산되는 너비값은 브라우저의 높이나 너비 중에 높이 값이 더 작으므로 500px을 기준으로 50vmin이나 500\*0.5 = 250픽셀이 지정

> 웹 접근성 : 웹 콘텐츠를 모든 사용자가 동등하게 접근할 수 있도록 제작하는 방법
> 웹 표준 :

https://medium.com/@matuzo/writing-css-with-accessibility-in-mind-8514a0007939

## (미완) 리액트 메모리 누수

컴포넌트가 마운트됐을 때 데이터를 호출시키는 비동기 코드를 짜야하는 경우가 많았다. 그런데 호출에 대한 응답 시간이 길어지고 사용자가 다른 페이지로 이동해 해당 컴포넌트가 언마운트된 경우, 요청을 취소하는 케이스를

## 포인터

## ✨ (미완) 뷰포트부터 반응형 웹

https://velog.io/@bityoungjae/%EB%B7%B0%ED%8F%AC%ED%8A%B8%EB%B6%80%ED%84%B0-%EB%B0%98%EC%9D%91%ED%98%95-%EC%9B%B9%EA%B9%8C%EC%A7%80-%EA%B0%9C%EB%85%90%EC%A0%95%EB%A6%AC

## ✨ 트러블슈팅 경험

= 웹 반응 지표와 관련한 => 웹 성능 개선 방법

## ✨ 성능 개선 관련 (네트워크/웹반응지표)

### 네트워크 관련한 => 웹 성능 개선 방법

1. 요청 헤더에 Connection: keep alive 설정을 유지한다.

   - 연속적으로 여러개의 요청을 보낼 때 매 요청마다 TCP 연결을 맺기 위한 작업이 수행되지 않도록 설정해, 네트워크 부하를 방지했다.

2. 캐시 컨트롤 작업을 수행한다.

   - 클라이언트가 리소스를 서버로 요청할 때 캐시 서버를 먼저 거치도록 작업해, 자주 사용되는 정적 파일들에 대한 요청을 기억시켜 리소스 접근을 빠르게 처리했다.
   - 캐시 정책은 유지 기간은 7일로 잡았고, 캐시 메모리 영역은 10mb로 설정했다.
   - 혹시나 너무 많은 파일이 하나의 캐시 폴더에 저장되면 속도에 문제가 될 것 같아 2단계 디렉터리 계층 구조로 설정했다.

3. 요청의 응답은 gzip으로 압축해 응답 파일의 크기를 줄이는 작업을 수행했다.

   - gzip 압축은 이미지보다는 텍스트 형식에서 더 권장되어 css, js, 그리고 텍스트 기반의 이미지 형식인 svg에만 적용했다.

이 작업들은 모두 nginx를 활용했다. 웹앱 앞단에 프록시 서버를 생성해 통신이 이루어지도록 처리하였다.

### 웹 반응 지표와 관련한 => 웹 성능 개선 방법

- 구글에서 제공해주는 웹 퍼포먼스 측정 도구인 lighthouse를 활용한다.

- 실무에서 대량의 페이지를 보여주는 주요 페이지에서 로딩 속도를 개선해야할 일이 있었다.

  - 성능 탭에서 긴 작업 시간에 해당하는 파일이 무엇인지 확인 후 해당 파일에 연산 코드가 있는 경우 매 렌더링마다 재활용될 수 있도록 메모라이제이션을 적용해놓고 실제 문제가 되었던 대량의 데이터를 불러오는 UI는 lazy 로딩으로 지연 로딩시켜 첫 화면의 로딩을 담당하는 js 파일을 가볍게 만들었다.
  - 그리고 문제되던 페이지의 본 목적이, 분석 결과를 보기위함이라는 것에 초점을 맞춰서 분석된 결과들 중 악성에 해당하는 영역만 UI에서 보여주고 나머지 우선순위가 낮은 데이터들은 사용자가 클릭했을 때 화면에 보여주는 형식으로 UI를 개선했다.
  - 그 결과 TTI (페이지가 사용자와 상호작용할 수 있을 때까지 걸리는 시간) 수치가 6초대에서 3초 이하로 떨어졌고 speed Index (빈화면에서 완전한 화면으로 채워지는데 걸리는 시간)도 light house 권장 속도인 4초 이내로 진입했고, TBT (페이지의 상호작용을 막은 총 시간) 시간도 300ms 이상에서 100 ms로 개선되었다.

## 보안 관련한 => 개선 방법

XSS(크로스 사이트 스크립팅) 공격을 방어하기 위해 JSX 문법을 활용했다. 해당 문법을 활용하면 브라우저가 화면에 렌더링되기 전에 스크립트를 포함한 모든 값들이 문자열로 변환되어 해당 공격을 방어할 수 있다.

데이터 변형과 연관된 API 요청의 경우 CSRF 공격을 방어하기 위해 X-CSRF 토큰 방식의 인증을 사용하고 있다. X-CSRF 토큰 방식을 사용하면 PUT, DELETE, POST 요청의 경우 헤더에 csrf 토큰이 자동으로 추가가 되지 않는다는 점을 활용해 방어하고 있다.

프론트 앞단에 프록시 서버를 생성해 프론트에서 서버로 요청하는 주소를 한단계 숨겨주는 부분 또한 적용되어 있고, CPS라는 (컨텐츠 보안 정책)을 사용해 일부 리소스의 경우 동일 출처 정책에 한해서만 허용하도록 적용되어 있다.

## ✨ 웹 반응 개선 지표들 - lighthouse 기준

**FCP (First Content Paint)**
페이지 로드가 시작된 후부터 화면에 첫 컨텐츠가 렌더링될 때까지의 시간을 측정.
권장 속도는 2초이내이다.

**speed index**
페이지가 빈화면에서 완전한 화면으로 채워지는데 걸리는 평균 시간을 측정.
권장 속도는 4초 이내이다.

(개선) 빈 화면이 유지되는 시간을 줄이는 방법으로 접근.

- 웹폰트가 적용된 텍스트의 경우 글꼴 로딩을 기다리지 말고 시스템에 기본 설정된 글꼴을 먼저 보여준다
- 지연 로딩할 수 있는 모듈의 경우 lazy 로딩으로 소스를 불러와 메인 js가 최종 페이지를 표시하는데 걸리는 속도를 높인다.

**TTI (Time to Interactive)**
페이지가 완전히 사용자와 상호작용할 수 있을 때까지 걸리는 시간 측정.
측정된 긴 작업들 중 마지막 긴 작업의 종료 시점이다.
권장 TTI는 4초 이내이다.

(개선)

- 긴 작업들의 수를 줄이기 위해 파일 용량을 축소.
  - 번들러를 활용해 줄바꿈과 공백을 제거해 배포하도록 파일을 압축시키는 방법.
  - 개발모드와 배포모드로 의존성 모듈을 나눠 관리해 배포할 때 불필요한 코드는 제거하는 방법.
  - 동시 이미지 로딩을 많이 하는 경우 이미지 최적화 작업으로 개선 필요

**TBT (Total Blocking Time)**
브라우저의 메인 스레드가 페이지의 상호 작용을 막은 총 시간을 측정.
FCP와 TTI 사이의 총 시간.
TBT 총 시간이 300ms을 넘지 않는걸 권장한다.

**LCP (Largest Contentful Paint)**
화면 컨텐츠 중 가장 넓은 영역을 차지하는 요소가 처음 로딩되는 시점.

> 이미지 최적화 (https://velog.io/@sehyunny/the-definitive-guide-to-image-optimization)

      - 아이콘 수준의 작은 이미지의 경우 압축력이 높은 webp 확장자 사용한다.
      - bg-image 보다는 image 태그를 사용해 세부 속성으로 최적화한다.
         - srcset를 사용해 브라우저 사이즈에 맞는 이미지를 불러오도록 선언.
         - 동적이고 가변형인 이미지의 경우 auto로 설정해 이미지가 늦게 떠서 레이아웃이 변경되거나 밀리지 않도록 처리.
         - loading="lazy" 속성을 부여해 화면에 바로 보일 필요없는 이미지의 경우 지연처리한다.
         - fetchpriority="high" 속성을 부여해 다른 컨텐츠보다 먼저 보이도록 우선 순위를 준다.

> 웹 글꼴 최적화

      - 브라우저가 글꼴 선언을 더 빨리 할 수 있도록 head 태그 안에 인라인형태로 폰트 선언하기.
      - 글꼴 확장자 중 폭 넓은 브라우저를 지원하고 압축률이 높은 WOFF2 확장자를 사용한다.
      - font-dispay:optional 성능이 우선인 경우 사용, 텍스트 표기가 0.1초안에 이루어져 빠른 렌더링이 장점이나 0.1가 넘으면 글꼴 로딩을 하지 않는 단점이 있다.
      - font-dispay:swap 성능과 최적화를 타협한 옵션으로, 글꼴 로드가 다 될 때까지 시스템 글꼴로 적용해놔서 글꼴이 교체되어도 레이아웃 변경이 일어나지 않도록 하는 방법.
      - font-dispay:block 성능보다는 뷰에 집중하는 옵션으로, 글꼴 로드가 다 되기 전까지 텍스트 표기를 지연한다. swap의 경우 텍스트 교체를 사용자가 눈으로 보기 때문에 거슬릴 수 있는데 이를 방지한다.

> js 최적화

      - 번들러 사용해 전체 코드를 압축하고 파일의 개수를 줄인다.
         - SplitChunk 속성을 활용해 여러개의 청크 코드에 같은 라이브러리를 활용하는 경우 한군데에서만 불러오도록 처리.
      - es모듈로 배포
      - 코드 분할을 통해 초기에 로드해야하는 파일의 용량을 줄인다.
         - 특정 이벤트의 경우 필요한 모듈은 동적으로 불러올 수 있도록 작업 (react에서는 React.lazy로 사용 가능)

> (https://web.dev/lcp/?utm_source=devtools)

**CLS (Cumulative Layout Shift)**
사용자가 예상하지 못한 레이아웃 변경을 경험하는 빈도를 측정.

> 진행된 작업 시간이 50ms 이상인 경우 긴 작업(Long Task)으로 간주한다.
> lighthouse의 기본값은 느린 연결 상태에서 페이지가 로드되는 걸 기준으로 웹 성능을 분석한다.
> LCP 시점이 다른 이유가 여기에 기인한다.
> https://medium.com/jung-han/%EB%9D%BC%EC%9D%B4%ED%8A%B8%ED%95%98%EC%9A%B0%EC%8A%A4-%EC%84%B1%EB%8A%A5-%EC%A7%80%ED%91%9C-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0-83df3dc96fb9

## 비동기 구문의 실행 방식과 순서에 대해서 이야기?

## CORS란? CORS를 해결하기 위한 방법을 아는 대로 모두 설명해 주시고 보통 어떤 방식으로 해결하는지 자주 사용하는 방법 1가지와 함께 실제 해결하신 경험을 공유

## SSR CSR

## 웹어셈블리

[cs지식정리](https://velog.io/@joy37/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-CS-%EC%A7%80%EC%8B%9D-%EC%A0%95%EB%A6%AC#3-%EB%8F%99%EA%B8%B0%EC%99%80-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%9D%98-%EC%9E%A5%EB%8B%A8%EC%A0%90)
