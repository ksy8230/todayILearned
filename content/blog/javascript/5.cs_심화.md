## 이벤트 핸들러란?

## 이벤트 위임?

## setState로 상태 변화를 해야 하는 이유?

## 방통대 관련 cs 준비

## 알고리즘 관련 -> 개선 방안 흐름으로 풀기

## 컴파일러는 뭐고 인터프리터는 뭔가요?

## 정확히 어떤 포트폴리오인지 세부 설명 준비

## 서버와의 통신을 위해 고려할 점

- 데이터 관점
- http 프로토콜 관점

## 데이터 가공 처리가 필요한 이유?

api를 호출했을 때 해당 ui에 꼭 필요한 데이터만 줬으면 좋겠지만 프로젝트가 복잡하고 커져서 서버가 도메인 단위로 코드를 관리해야하는 경우 데이터가 브라우저에 렌더링되기 위한 가공이 필요하다.
예를 들어 프론트는 응답 받은 데이터리스트가 없는 경우의 조건식을 추가해 UI를 보여줘야하거나
응답받은 리스트들 중 악성 태그가 붙은 리스트만 보여줘야하는 경우 필터링을 시키는 작업과 같은 가공이 필요하다.

## 데이터 가공 처리 어떻게 했나?

이런 조건식을 추가하고 필터링 코드를 붙이는 작업 자체는 어렵지않지만
매 페이지마다 미묘하게 필요한 데이터들이 달라서 그때마다 가공처리 코드를 붙이는게 지저분하다 판단했다.

https://velog.io/@jjunyjjuny/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EA%B0%80%EA%B3%B5%ED%95%98%EB%9D%BC

### Class Instance로 변환

Class의 Instance를 활용해 가공 처리 작업을 개선해보았다.
Class를 활용하게 되면 데이터를 가공하는 책임을 해당 클래스에게 위임을 할 수 있어서 가공처리와 관련된 코드의 응집성이 높아진다.

예를 들어서 url 리스트에 관련된 가공 데이터가 필요한 경우 UrlData라는 클래스를 만들어 내부에 데이터리스트가 없는 경우 (getter 메서드를 활용해) isEmpty라는 프로퍼티를 만들어둔다. 그리고 외부에서 필요한 가공처리가 적용된 속성을 사용할 수 있도록 코드를 개선해본 경험이 있다.

1. 이렇게 되면 가공처리 코드가 여기저기에 산재되어있는게 아니라 한군데에 묶어서 관리할 수 있고,
2. UI를 렌더링하는 코드에선 가공처리로직이 빠지면서 view 역할에 집중할 수 있게 된다.
3. 서버의 API 응답 스키마가 확정되지 않은 상태라도 클라이언트에서 사용할 데이터의 인터페이스를 우선 정의해둘 수 있어서 API가 미완성일지라도 레이아웃 작업을 먼저 진행할 수 있다.
   - 4. 나중에 API에서 내려준 데이터가 달라져도 view단은 건드릴 필요가 없고 데이터 가공 클래스에서 수정해주면 되니 유지보수면에서도 장점이 있다.

- 서버는 어느 한 도메인에 맞추지 않고 어떤 요청에도 유연하게 대응할 수 있는 구조를 갖추어야한다.
- Class : 접근자 프로퍼티(get, set)를 사용하면 바깥 코드에서 일반 프로퍼티처럼 사용할 수 있다.

## 인스턴스와 메모리
