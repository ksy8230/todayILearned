{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/project/work/kubernetes/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Today I Learned"}},"markdownRemark":{"id":"aed27215-3e43-5b0c-ae94-cf24b2b6e761","excerpt":"목표 사내에서 앞으로 작업될 환경이 쿠버네티스로 이루어진다고 하는데 하나도 못 알아듣겠어서 혼자 학습해 본다. 쿠버네티스란? 컨테이너 오케스트레이션.\r\n컨테이너를 빠르게 배포/확장이 가능하고 관리를 자동화시켜주는 오픈소스 플랫폼이다. 201…","html":"<h3>목표</h3>\n<p>사내에서 앞으로 작업될 환경이 쿠버네티스로 이루어진다고 하는데 하나도 못 알아듣겠어서 혼자 학습해 본다.</p>\n<h3>쿠버네티스란?</h3>\n<p>컨테이너 오케스트레이션.\r\n컨테이너를 빠르게 배포/확장이 가능하고 관리를 자동화시켜주는 오픈소스 플랫폼이다.<br>\n2015년도에 구글에 의해 출시됐고, 현재 아주 거대한 커뮤니티를 형성 중이다.<br>\n하나의 서버가 아닌 굉장히 많은 서버에서 도커를 사용하게 된다면 우리는 가장 이상적인 상태의 서버를 선별해 해당 서버에 도커 컨테이너를 생성해야 한다.<br>\n이 행위를 사람이 일일이 그 많은 서버들에게 접근해 남는 자원이 많은지 확인하는 과정은 굉장히 비효율적인데… 이것을 쿠버네티스가 대신 해 준다고 보면 된다.</p>\n<h3>들어가기 전에 가상머신 vs 컨테이너 차이부터</h3>\n<h4>가상머신</h4>\n<p><img src=\"https://user-images.githubusercontent.com/24996316/154515156-444cedf1-a47e-4f9d-89ce-59297db14438.png\" alt=\"image\"></p>\n<p>가상머신의 구조는 위의 이미지와 같이, 하드웨어 위에 하이퍼바이저를 두고 독립된 환경의 운영 시스템을 여러개 생성한다. 이런 구조의 장점은 각 환경마다 필요한 리소스가 많거나 적은 경우에 맞춰서 하드웨어 자원을 할당시켜줄 수 있다는 점에 있다. 하지만 특정 머신이 다운되어 버리면? 😕<br>\n이런 경우를 방지하기 위해 수평 확장 형식으로 아래와 같이 필요한 머신을 수평적으로 여러개 생성시켜주는 방식을 요즘은 많이 쓴다고 한다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/24996316/154516264-3433270d-22dc-458f-a5bb-95886f1a7f69.png\" alt=\"image\"></p>\n<h4>컨테이너</h4>\n<p>컨테이너 방식의 구조는 아래와 같다.</p>\n<p>컨테이너|컨테이너|…</p>\n<ul>\n<li>도커</li>\n<li>호스트 운영체제</li>\n<li>하드웨어</li>\n<li></li>\n</ul>\n<p>컨테이너는 가상머신과는 다르게 머신을 생성할 때마다 운영체제를 설치할 필요가 없으므로 일단 가볍다.<br>\n가볍기 때문에 수평확장의 경우도 당연히 컨테이너로 만든 어플리케이션이 빠르게 확산되고 빠르게 축소되는 이점을 가져간다.</p>\n<p>즉, 컨테이너 방식은 배포를 효율적으로 할 수 있다.<br>\n그런데 만일 컨테이너들을 수평 확장시키고 있는 서버 자체에 오류가 생겨버리면 어떡할까?<br>\n이 경우를 대비하기 위해 나온 것이 멀티 호스트 도커 플랫폼이다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/24996316/154518497-f3f72350-1776-4eb9-a0cf-a35bc03a6bee.png\" alt=\"image\"></p>\n<p>하지만 여전히 문제는 존재한다. 서버를 여러대 뒀지만 특정 컨테이너를 서버에 할당시켜야할 때 그 기준을 사람이 일일이 서버마다 체크해서 할당시켜야하는 번거로움이 생겼다.</p>\n<p><img src=\"https://user-images.githubusercontent.com/24996316/154519434-bbe896a6-316f-46e8-a0d2-6c8389ac3a10.png\" alt=\"image\"></p>\n<p>초반부에 나온 쿠버네티스가 이것을 해결해 준다. 컨트롤 패널이라는 마스터 서버가 다른 일꾼 서버들을 관리해 주며 넉넉한 자원을 가진 서버를 마스터 서버가 알아서 찾아서 추가로 더 필요한 컨테이너를 똑똑하게 복제해서 넣어준다.</p>\n<h3>용어 정리</h3>\n<p>크게 마스터 노드, 워커 노드 각각에 관련된 용어로 분류하여 정리해 보자.</p>\n<h4>마스터 관련</h4>\n<p>kube-apiserver, 쿠브-api서버: 마스터로 전달되는 모든 요청을 받아드리는 REST API 서버<br>\netcd: 클러스터내 모든 메타 정보를 저장하는 저장소<br>\nkube-scheduler: 사용자 요청에 따라 적절하게 컨테이너를 워커 노드에 배치하는 스케줄러<br>\nkube-controller-manager: 현재 상태와 바라는 상태를 지속적으로 확인하며 특정 이벤트에 따라 특정 동작을 수행하는 컨트롤러<br>\ncloud-controller-manager: 클라우드 플랫폼(ex. AWS)에 특화된 리소스를 제어하는 클라우드 컨트롤러</p>\n<h4>워커 관련</h4>\n<p>kubelet: 마스터 명령에 따라 컨테이너의 라이프 사이클을 관리하는 노드 관리자로 각 노드에서 실행되는 메인<br>\nkube-proxy: 컨테이너의 네트워킹을 책임지는 프록시<br>\ncontainer runtime: 실제 컨테이너를 실행하는 컨테이너 실행 환경</p>\n<h3>도움 받은 자료</h3>\n<p><a href=\"https://www.youtube.com/watch?v=Sj9Z6-w1VUE&#x26;list=PLApuRlvrZKohaBHvXAOhUD-RxD0uQ3z0c&#x26;index=2\">따베쿠</a></p>","frontmatter":{"title":"쿠버네티스란","date":"2022-02-15","description":null,"tags":["kubenetes"]}},"previous":{"fields":{"slug":"/setting/react/without-CRA/"},"frontmatter":{"title":"React 프로젝트 CRA 없이 세팅하기"}},"next":{"fields":{"slug":"/algorithm/bigO/"},"frontmatter":{"title":"빅오 표기법"}}},"pageContext":{"id":"aed27215-3e43-5b0c-ae94-cf24b2b6e761","previousPostId":"00f7e728-963c-5439-963f-dcd0fb2d9756","nextPostId":"3cbd35c1-4f45-51c7-929a-8f73086537e7"}},
    "staticQueryHashes": ["2841359383","3708219967"]}