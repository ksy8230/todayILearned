{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/project/work/gitlab_cicd/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Today I Learned"}},"markdownRemark":{"id":"6eaa36b8-33c7-5607-a661-ce24e8fdc912","excerpt":"목표 웹서버에 올릴 프론트 파일을 깃랩을 이용해 자동 배포하도록 설정해 본다. 어떻게 돌아가는 걸까 & 시나리오 깃랩의 cicd는 도커에서 돌아간다. 그리고 연결된 쿠버네티스에 배포가 된다. (@.@? 쿠버네티스가 뭔지 모르겠지만 일단은 넘어가자) 깃랩의 cicd…","html":"<h3>목표</h3>\n<p>웹서버에 올릴 프론트 파일을 깃랩을 이용해 자동 배포하도록 설정해 본다.</p>\n<h3>어떻게 돌아가는 걸까 &#x26; 시나리오</h3>\n<p>깃랩의 cicd는 도커에서 돌아간다. 그리고 연결된 쿠버네티스에 배포가 된다. (@.@? 쿠버네티스가 뭔지 모르겠지만 일단은 넘어가자) 깃랩의 cicd는 프로젝트의 루트 위치에 .gitlab-ci.yml이 있는 상태에서 새로운 푸시가 들어오면 yml에 작성된 명령어들이 일련의 묶음으로 연결되어 실행된다. 이것을 파이프라인이라고도 한다.<br>\n내가 하고픈 cicd의 전반적인 그림은 아래와 같다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/todayILearned/static/88c579e2db04f4e5f530f4f29707032e/2ee51/gitlab_cicd_image1.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 44.30379746835443%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAexqUIP/xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAEFAl//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAYEAEBAAMAAAAAAAAAAAAAAAABABARIf/aAAgBAQABPyHsE6y3/9oADAMBAAIAAwAAABDgz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EAB0QAQABAwUAAAAAAAAAAAAAAAEAESExEEFRYaH/2gAIAQEAAT8QW6gdXhUueRhCm3GhiZT/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"gitlab cicd image1\"\n        title=\"gitlab cicd image1\"\n        src=\"/todayILearned/static/88c579e2db04f4e5f530f4f29707032e/828fb/gitlab_cicd_image1.jpg\"\n        srcset=\"/todayILearned/static/88c579e2db04f4e5f530f4f29707032e/ff44c/gitlab_cicd_image1.jpg 158w,\n/todayILearned/static/88c579e2db04f4e5f530f4f29707032e/a6688/gitlab_cicd_image1.jpg 315w,\n/todayILearned/static/88c579e2db04f4e5f530f4f29707032e/828fb/gitlab_cicd_image1.jpg 630w,\n/todayILearned/static/88c579e2db04f4e5f530f4f29707032e/0ede0/gitlab_cicd_image1.jpg 945w,\n/todayILearned/static/88c579e2db04f4e5f530f4f29707032e/2ee51/gitlab_cicd_image1.jpg 1043w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<ol>\n<li>우선 로컬 피시에서 리액트 코드를 작성하고 master 브랜치에 커밋하면</li>\n<li>깃랩의 러너가 변화를 감지해 작성해둔 .gitlab-ci.yml 파일의 스테이지 단계대로 실행한다</li>\n<li>yml 파일은 크게 도커 빌드 단계, 배포 단계로 구성했다.</li>\n<li>빌드 단계에서 docker in docker 이미지를 받아와 도커 안의 도커에서 이미지를 만들어 도커 레지스트리(a.k.a 팀 내부용 도커 허브)에 등록한다.</li>\n<li>배포 단계에서 kroniak/ssh-client 이미지를 받아와 ssh 연결을 통해 배포 서버에서 도커 레지스트리에서 이미지를 당겨와 배포한다.</li>\n</ol>\n<p><strong>dind란?</strong><br>\n도커 호스트 내부에 또 다른 도커를 서비스 형태로 실행시킨다.</p>\n<h3>1. 웹 어플리케이션으로 활용할 프로젝트 생성</h3>\n<p>나의 경우 create-react-app 명령어를 이용해 보일러 프로젝트로 간단하게만 만들어보았다.</p>\n<h3>2. 루트 위치에 yml 파일 생성</h3>\n<p>깃랩 cicd 파이프라인 기능을 사용하기 위해선 yml 파일을 작성해야 한다. 그리고 이 파일은 <strong>프로젝트의 루트 폴더</strong>에 위치해야 한다. (나의 경우 package.json과 동일한 위치에 해당 파일을 작성)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">stages:\r\n  - build\r\n  - deploy\r\n\r\ndocker-build:\r\n  stage: build\r\n  tags:\r\n    - ci-tag\r\n  image: docker:stable\r\n  services:\r\n    - name: docker:dind\r\n      command: ['--tls=false', '--insecure-registry=$DOCKER_REGISTRY']\r\n  variables:\r\n    DOCKER_HOST: tcp://docker:2375/\r\n    DOCKER_DRIVER: overlay2\r\n    DOCKER_TLS_CERTDIR: ''\r\n  before_script:\r\n    - docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" $CI_REGISTRY\r\n  script:\r\n    - docker build -t project-name .\r\n    - docker tag project-name $DOCKER_REGISTRY/project-name\r\n    - docker push $DOCKER_REGISTRY/project-name\r\n\r\ndeploy_dev:\r\n  stage: deploy\r\n  tags:\r\n    - ci-tag\r\n  needs: [docker-build]\r\n  image: kroniak/ssh-client\r\n  before_script:\r\n    - echo \"deploying app\"\r\n  script:\r\n    - echo \"$SSH_PRIVATE_KEY\" | tr -d '\\r' > key.pem\r\n    - chmod 400 key.pem\r\n    - ssh -o StrictHostKeyChecking=no -i key.pem root@$PROD_SERVER_IP -p 6879 'docker stop projectcontainer || true &amp;&amp; docker rm projectcontainer || true'\r\n    - ssh -o StrictHostKeyChecking=no -i key.pem root@$PROD_SERVER_IP -p 6879 'docker pull $DOCKER_REGISTRY/project-name'\r\n    - ssh -o StrictHostKeyChecking=no -i key.pem root@$PROD_SERVER_IP -p 6879 'docker run -p 3001:80 -d --name projectcontainer $DOCKER_REGISTRY/project-name'\r\n  only:\r\n    - master</code></pre></div>\n<p>배포 자동화의 단계는 크게 총 두단계이다. 빌드-배포.</p>\n<h4>빌드</h4>\n<p>배포 스테이지에서 깃랩은 docker in docker를 실행시킨다. 그리고 깃랩에 등록한 러너가 sciprt: 부분을 실행시키기 전에 도커로 로그인한다.<br>\n이후 러너는 script:에 적힌 순서대로 도커 명령어를 실행한다.</p>\n<ol>\n<li>project-name이라는 이름의 도커 이미지를 생성한다</li>\n<li>project-name 도커 이미지에 tag 이름으로 $DOCKER_REGISTRY/project-name를 붙여준다</li>\n<li>도커 레지스트리($DOCKER_REGISTRY)에 $DOCKER_REGISTRY/project-name tag 이름을 가진 도커 이미지를 푸시한다</li>\n</ol>\n<blockquote>\n<p><strong>dind secure error 443</strong></p>\n</blockquote>\n<p>도커 속 도커에서 도커 레지스트리로 이미지를 push하려는데 443 connect 에러가 떴다. 도커는 통신을 할 때 https 통신을 디폴트로 하는데 우리가 가진 도커 레지스트리가 https 통신 오픈이 되어있지 않았다. 그래서 **도커 서비스의 커맨드 명령어에 ‘—insecure-registry=$DOCKER_REGISTRY’ 이 옵션을 주어 해결.</p>\n<h4>배포</h4>\n<p>빌드 스테이지에서 깃랩은 kroniak/ssh-client을 실행시킨다.<br>\n이후 러너는 script:에 적힌 순서대로 도커 명령어를 실행한다.</p>\n<ol>\n<li>key.pem 파일의 권한 설정하여 접근 획득</li>\n<li>ssh 명령어를 이용해 배포하고자하는 서버에 ‘우리가 실행시키고자하는 컨테이너가 있다면 스탑 후 제거한다’ &#x3C;- 컨테이너 중복 에러 방지</li>\n<li>ssh 명령어를 이용해 배포하고자하는 서버에서 빌드 단계에서 push 했던 $DOCKER_REGISTRY/project-name 이미지를 가져온다</li>\n<li>ssh 명령어를 이용해 배포하고자하는 서버에서 ‘가져온 이미지를 도커 컨테이너로 실행한다. 이때 호스트의 포트는 3001 포트이고 컨테이너의 포트는 80 포트를 이용해 연결한다’</li>\n</ol>\n<blockquote>\n<p><strong>ssh 명령어를 이용해 서버와 통신을 하기 위한 key 생성</strong></p>\n</blockquote>\n<p><code class=\"language-text\">ssh-keygen -m PEM -t rsa -b 4096 -C \"email@co.kr\"</code><br>\n위 명령어를 서버에서 실행하면 id_rsa, id_rsa.pub 키를 생성하고 전자의 키를 복사해 깃랩에서 $SSH_PRIVATE_KEY 환경변수로 지정 후 사용한다</p>\n<h3>3. 깃랩 러너 등록</h3>\n<ul>\n<li>공유 러너와 개별 러너, 차이점에 대해 공부하기</li>\n</ul>\n<h3>4. 그 외 기억할 것들</h3>\n<ul>\n<li>*ssh private key 복사할 때 인코딩이 LF인지 꼭 확인하자</li>\n<li></li>\n</ul>","frontmatter":{"title":"깃랩 cicd","date":"January 22, 2022","description":null,"tags":[]}},"previous":{"fields":{"slug":"/docker/practice/react-nginx-docker/"},"frontmatter":{"title":"리액트 어플리케이션을 nginx 정적 서버에 배포하는 도커 이미지 만들기"}},"next":{"fields":{"slug":"/project/work/nignx_500_error/"},"frontmatter":{"title":"nginx 500 permission error"}}},"pageContext":{"id":"6eaa36b8-33c7-5607-a661-ce24e8fdc912","previousPostId":"d04cfb32-12db-5ede-aeec-0b051345d383","nextPostId":"c5c57cce-f131-5da8-b480-306d82fc3d45"}},
    "staticQueryHashes": ["2841359383","3382539634"]}