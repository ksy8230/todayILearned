{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/project/work/gitlab_cicd/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Today I Learned"}},"markdownRemark":{"id":"6eaa36b8-33c7-5607-a661-ce24e8fdc912","excerpt":"목표 웹서버에 올릴 프론트 파일을 깃랩을 이용해 자동 배포하도록 설정해 본다. 어떻게 돌아가는 걸까 & 시나리오 깃랩의 cicd는 도커에서 돌아간다. 그리고 연결된 쿠버네티스에 배포가 된다. (@.@? 쿠버네티스가 뭔지 모르겠지만 일단은 넘어가자) 깃랩의 cicd…","html":"<h3>목표</h3>\n<p>웹서버에 올릴 프론트 파일을 깃랩을 이용해 자동 배포하도록 설정해 본다.</p>\n<h3>어떻게 돌아가는 걸까 &#x26; 시나리오</h3>\n<p>깃랩의 cicd는 도커에서 돌아간다. 그리고 연결된 쿠버네티스에 배포가 된다. (@.@? 쿠버네티스가 뭔지 모르겠지만 일단은 넘어가자) 깃랩의 cicd는 프로젝트의 루트 위치에 .gitlab-ci.yml이 있는 상태에서 새로운 푸시가 들어오면 yml에 작성된 명령어들이 일련의 묶음으로 연결되어 실행된다. 이것을 파이프라인이라고도 한다.<br>\n내가 하고픈 cicd의 전반적인 그림은 아래와 같다.</p>\n<ol>\n<li>우선 로컬 피시에서 리액트 코드를 작성하고 master 브랜치에 커밋하면</li>\n<li>깃랩의 러너가 변화를 감지해 작성해둔 .gitlab-ci.yml 파일의 스테이지 단계대로 실행한다</li>\n<li>yml 파일은 크게 도커 빌드 단계, 배포 단계로 구성했다.</li>\n<li>빌드 단계에서 docker in docker 이미지를 받아와 도커 안의 도커에서 이미지를 만들어 도커 레지스트리(a.k.a 팀 내부용 도커 허브)에 등록한다.</li>\n<li>배포 단계에서 kroniak/ssh-client 이미지를 받아와 ssh 연결을 통해 배포 서버에서 도커 레지스트리에서 이미지를 당겨와 배포한다.</li>\n</ol>\n<p>**dind란?<br>\n도커 호스트 내부에 또 다른 도커 데몬을 생성해 실행시킨다. 또한 —privileged 명령어를 사용해 호스트의 모든 권한을 도커 내부의 도커에게 부여한다.</p>\n<h3>1. 웹 어플리케이션으로 활용할 프로젝트 생성</h3>\n<p>나의 경우 create-react-app 명령어를 이용해 보일러 프로젝트로 간단하게만 만들어보았다.</p>\n<h3>2. 루트 위치에 yml 파일 생성</h3>\n<p>깃랩 cicd 파이프라인 기능을 사용하기 위해선 yml 파일을 작성해야 한다. 그리고 이 파일은 <strong>프로젝트의 루트 폴더</strong>에 위치해야 한다. (나의 경우 package.json과 동일한 위치에 해당 파일을 작성)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">cache:\r\n  paths:\r\n    - node_modules/\r\n\r\nstages:\r\n  - build\r\n  - docker-build\r\n\r\nbuild:\r\n  stage: build\r\n  tags:\r\n    - kisa-ci\r\n  image: node:16-alpine\r\n  before_script:\r\n    - GENERATE_SOURCEMAP=false\r\n  script:\r\n    - npm install\r\n    - CI=false npm run build\r\n  artifacts:\r\n    expire_in: 1 hour\r\n    paths:\r\n      - ./build\r\n\r\ndocker-build:\r\n  stage: docker-build\r\n  tags:\r\n    - kisa-ci\r\n  image: docker:latest\r\n  services:\r\n    - name: docker:19.03.8-dind\r\n  before_script:\r\n    - docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" $CI_REGISTRY\r\n  script:\r\n    - docker build --pull -t \"$CI_REGISTRY_IMAGE\" .\r\n    - docker push \"$CI_REGISTRY_IMAGE\"\r\n    - echo \"Registry image:\" $CI_REGISTRY_IMAGE</code></pre></div>\n<h3>3. 깃랩 러너 등록</h3>\n<ul>\n<li>공유 러너와 개별 러너, 차이점에 대해 공부하기</li>\n</ul>\n<h3>4. 배포 스테이지</h3>\n<div class=\"gatsby-highlight\" data-language=\"docker\"><pre class=\"language-docker\"><code class=\"language-docker\">deploy:\r\n  stage: deploy\r\n  tags:\r\n    - kisa-ci\r\n  image: kroniak/ssh-client\r\n  before_script:\r\n    - echo \"deploying app\"\r\n  script:\r\n    - echo \"$SSH_PRIVATE_KEY\" | tr -d '\\r' > key.pem\r\n    - chmod 400 key.pem\r\n    - ssh -o StrictHostKeyChecking=no -i key.pem &lt;username>@$PROD_SERVER_IP -p 6879 'docker stop &lt;containername> || true &amp;&amp; docker rm &lt;containername> || true'\r\n    - ssh -o StrictHostKeyChecking=no -i key.pem &lt;username>@$PROD_SERVER_IP -p 6879 'docker run -p 3001:80 -d --name &lt;containername> &lt;imagename>'</code></pre></div>\n<ul>\n<li>ssh private key 복사할 때 인코딩이 LF인지 꼭 확인하자</li>\n<li></li>\n</ul>","frontmatter":{"title":"깃랩 cicd","date":"January 22, 2022","description":null,"tags":[]}},"previous":{"fields":{"slug":"/docker/practice/react-nginx-docker/"},"frontmatter":{"title":"리액트 어플리케이션을 nginx 정적 서버에 배포하는 도커 이미지 만들기"}},"next":{"fields":{"slug":"/project/work/nignx_500_error/"},"frontmatter":{"title":"nginx 500 permission error"}}},"pageContext":{"id":"6eaa36b8-33c7-5607-a661-ce24e8fdc912","previousPostId":"d04cfb32-12db-5ede-aeec-0b051345d383","nextPostId":"c5c57cce-f131-5da8-b480-306d82fc3d45"}},
    "staticQueryHashes": ["2841359383","3382539634"]}